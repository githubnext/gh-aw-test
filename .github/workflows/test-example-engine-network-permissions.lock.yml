# This file was automatically generated by gh-aw. DO NOT EDIT.
# To update this file, edit the corresponding .md file and run:
#   gh aw compile

name: "Secure Web Research Task"
on:
  pull_request:
    branches:
    - main
    # forks: [] # Fork filtering applied via job conditions
  workflow_dispatch: null

permissions: {}

concurrency:
  group: "gh-aw-${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}"
  cancel-in-progress: true

run-name: "Secure Web Research Task"

jobs:
  task:
    if: (github.event_name != 'pull_request') || (github.event.pull_request.head.repo.full_name == github.repository)
    runs-on: ubuntu-latest
    permissions:
      actions: write  # Required for github.rest.actions.cancelWorkflowRun()
    steps:
      - name: Check team membership for workflow
        id: check-team-member
        uses: actions/github-script@v7
        env:
          GITHUB_AW_REQUIRED_ROLES: admin,maintainer
        with:
          script: |
            async function setCancelled(message) {
              try {
                await github.rest.actions.cancelWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: context.runId,
                });
                core.info(`Cancellation requested for this workflow run: ${message}`);
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                core.warning(`Failed to cancel workflow run: ${errorMessage}`);
                core.setFailed(message); // Fallback if API call fails
              }
            }
            async function main() {
              const { eventName } = context;
              // skip check for safe events
              const safeEvents = ["workflow_dispatch", "workflow_run", "schedule"];
              if (safeEvents.includes(eventName)) {
                core.info(`✅ Event ${eventName} does not require validation`);
                return;
              }
              const actor = context.actor;
              const { owner, repo } = context.repo;
              const requiredPermissionsEnv = process.env.GITHUB_AW_REQUIRED_ROLES;
              const requiredPermissions = requiredPermissionsEnv
                ? requiredPermissionsEnv.split(",").filter(p => p.trim() !== "")
                : [];
              if (!requiredPermissions || requiredPermissions.length === 0) {
                core.error(
                  "❌ Configuration error: Required permissions not specified. Contact repository administrator."
                );
                await setCancelled(
                  "Configuration error: Required permissions not specified"
                );
                return;
              }
              // Check if the actor has the required repository permissions
              try {
                core.debug(
                  `Checking if user '${actor}' has required permissions for ${owner}/${repo}`
                );
                core.debug(`Required permissions: ${requiredPermissions.join(", ")}`);
                const repoPermission =
                  await github.rest.repos.getCollaboratorPermissionLevel({
                    owner: owner,
                    repo: repo,
                    username: actor,
                  });
                const permission = repoPermission.data.permission;
                core.debug(`Repository permission level: ${permission}`);
                // Check if user has one of the required permission levels
                for (const requiredPerm of requiredPermissions) {
                  if (
                    permission === requiredPerm ||
                    (requiredPerm === "maintainer" && permission === "maintain")
                  ) {
                    core.info(`✅ User has ${permission} access to repository`);
                    return;
                  }
                }
                core.warning(
                  `User permission '${permission}' does not meet requirements: ${requiredPermissions.join(", ")}`
                );
              } catch (repoError) {
                const errorMessage =
                  repoError instanceof Error ? repoError.message : String(repoError);
                core.error(`Repository permission check failed: ${errorMessage}`);
                await setCancelled(`Repository permission check failed: ${errorMessage}`);
                return;
              }
              // Cancel the workflow when permission check fails
              core.warning(
                `❌ Access denied: Only authorized users can trigger this workflow. User '${actor}' is not authorized. Required permissions: ${requiredPermissions.join(", ")}`
              );
              await setCancelled(
                `Access denied: User '${actor}' is not authorized. Required permissions: ${requiredPermissions.join(", ")}`
              );
            }
            await main();

  secure-web-research-task:
    needs: task
    if: (github.event_name != 'pull_request') || (github.event.pull_request.head.repo.full_name == github.repository)
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
      - name: Generate Claude Settings
        run: |
          mkdir -p /tmp/.claude
          cat > /tmp/.claude/settings.json << 'EOF'
          {
            "hooks": {
              "PreToolUse": [
                {
                  "matcher": "WebFetch|WebSearch",
                  "hooks": [
                    {
                      "type": "command",
                      "command": ".claude/hooks/network_permissions.py"
                    }
                  ]
                }
              ]
            }
          }
          EOF
      - name: Generate Network Permissions Hook
        run: |
          mkdir -p .claude/hooks
          cat > .claude/hooks/network_permissions.py << 'EOF'
          #!/usr/bin/env python3
          """
          Network permissions validator for Claude Code engine.
          Generated by gh-aw from engine network permissions configuration.
          """
          
          import json
          import sys
          import urllib.parse
          import re
          
          # Domain allow-list (populated during generation)
          ALLOWED_DOMAINS = ["docs.github.com"]
          
          def extract_domain(url_or_query):
              """Extract domain from URL or search query."""
              if not url_or_query:
                  return None
              
              if url_or_query.startswith(('http://', 'https://')):
                  return urllib.parse.urlparse(url_or_query).netloc.lower()
              
              # Check for domain patterns in search queries
              match = re.search(r'site:([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', url_or_query)
              if match:
                  return match.group(1).lower()
              
              return None
          
          def is_domain_allowed(domain):
              """Check if domain is allowed."""
              if not domain:
                  # If no domain detected, allow only if not under deny-all policy
                  return bool(ALLOWED_DOMAINS)  # False if empty list (deny-all), True if has domains
              
              # Empty allowed domains means deny all
              if not ALLOWED_DOMAINS:
                  return False
              
              for pattern in ALLOWED_DOMAINS:
                  regex = pattern.replace('.', r'\.').replace('*', '.*')
                  if re.match(f'^{regex}$', domain):
                      return True
              return False
          
          # Main logic
          try:
              data = json.load(sys.stdin)
              tool_name = data.get('tool_name', '')
              tool_input = data.get('tool_input', {})
              
              if tool_name not in ['WebFetch', 'WebSearch']:
                  sys.exit(0)  # Allow other tools
              
              target = tool_input.get('url') or tool_input.get('query', '')
              domain = extract_domain(target)
              
              # For WebSearch, apply domain restrictions consistently
              # If no domain detected in search query, check if restrictions are in place
              if tool_name == 'WebSearch' and not domain:
                  # Since this hook is only generated when network permissions are configured,
                  # empty ALLOWED_DOMAINS means deny-all policy
                  if not ALLOWED_DOMAINS:  # Empty list means deny all
                      print(f"Network access blocked: deny-all policy in effect", file=sys.stderr)
                      print(f"No domains are allowed for WebSearch", file=sys.stderr)
                      sys.exit(2)  # Block under deny-all policy
                  else:
                      print(f"Network access blocked for web-search: no specific domain detected", file=sys.stderr)
                      print(f"Allowed domains: {', '.join(ALLOWED_DOMAINS)}", file=sys.stderr)
                      sys.exit(2)  # Block general searches when domain allowlist is configured
              
              if not is_domain_allowed(domain):
                  print(f"Network access blocked for domain: {domain}", file=sys.stderr)
                  print(f"Allowed domains: {', '.join(ALLOWED_DOMAINS)}", file=sys.stderr)
                  sys.exit(2)  # Block with feedback to Claude
              
              sys.exit(0)  # Allow
              
          except Exception as e:
              print(f"Network validation error: {e}", file=sys.stderr)
              sys.exit(2)  # Block on errors
          
          EOF
          chmod +x .claude/hooks/network_permissions.py
      - name: Setup MCPs
        run: |
          mkdir -p /tmp/mcp-config
          cat > /tmp/mcp-config/mcp-servers.json << 'EOF'
          {
            "mcpServers": {
              "github": {
                "command": "docker",
                "args": [
                  "run",
                  "-i",
                  "--rm",
                  "-e",
                  "GITHUB_PERSONAL_ACCESS_TOKEN",
                  "ghcr.io/github/github-mcp-server:sha-09deac4"
                ],
                "env": {
                  "GITHUB_PERSONAL_ACCESS_TOKEN": "${{ secrets.GITHUB_TOKEN }}"
                }
              }
            }
          }
          EOF
      - name: Create prompt
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
        run: |
          mkdir -p /tmp/aw-prompts
          cat > $GITHUB_AW_PROMPT << 'EOF'
          # Secure Web Research Task
          
          Please research the GitHub API documentation or Stack Overflow and find information about repository topics. Summarize them in a brief report.
          
          EOF
      - name: Print prompt to step summary
        run: |
          echo "## Generated Prompt" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````markdown' >> $GITHUB_STEP_SUMMARY
          cat $GITHUB_AW_PROMPT >> $GITHUB_STEP_SUMMARY
          echo '``````' >> $GITHUB_STEP_SUMMARY
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
      - name: Generate agentic run info
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            const awInfo = {
              engine_id: "claude",
              engine_name: "Claude Code",
              model: "",
              version: "",
              workflow_name: "Secure Web Research Task",
              experimental: false,
              supports_tools_whitelist: true,
              supports_http_transport: true,
              run_id: context.runId,
              run_number: context.runNumber,
              run_attempt: process.env.GITHUB_RUN_ATTEMPT,
              repository: context.repo.owner + '/' + context.repo.repo,
              ref: context.ref,
              sha: context.sha,
              actor: context.actor,
              event_name: context.eventName,
              staged: false,
              created_at: new Date().toISOString()
            };
            
            // Write to /tmp directory to avoid inclusion in PR
            const tmpPath = '/tmp/aw_info.json';
            fs.writeFileSync(tmpPath, JSON.stringify(awInfo, null, 2));
            console.log('Generated aw_info.json at:', tmpPath);
            console.log(JSON.stringify(awInfo, null, 2));
      - name: Upload agentic run info
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: aw_info.json
          path: /tmp/aw_info.json
          if-no-files-found: warn
      - name: Execute Claude Code Action
        id: agentic_execution
        uses: anthropics/claude-code-base-action@v0.0.56
        with:
          # Allowed tools (sorted):
          # - ExitPlanMode
          # - Glob
          # - Grep
          # - LS
          # - NotebookRead
          # - Read
          # - Task
          # - TodoWrite
          # - WebFetch
          # - WebSearch
          # - mcp__github__download_workflow_run_artifact
          # - mcp__github__get_code_scanning_alert
          # - mcp__github__get_commit
          # - mcp__github__get_dependabot_alert
          # - mcp__github__get_discussion
          # - mcp__github__get_discussion_comments
          # - mcp__github__get_file_contents
          # - mcp__github__get_issue
          # - mcp__github__get_issue_comments
          # - mcp__github__get_job_logs
          # - mcp__github__get_me
          # - mcp__github__get_notification_details
          # - mcp__github__get_pull_request
          # - mcp__github__get_pull_request_comments
          # - mcp__github__get_pull_request_diff
          # - mcp__github__get_pull_request_files
          # - mcp__github__get_pull_request_reviews
          # - mcp__github__get_pull_request_status
          # - mcp__github__get_secret_scanning_alert
          # - mcp__github__get_tag
          # - mcp__github__get_workflow_run
          # - mcp__github__get_workflow_run_logs
          # - mcp__github__get_workflow_run_usage
          # - mcp__github__list_branches
          # - mcp__github__list_code_scanning_alerts
          # - mcp__github__list_commits
          # - mcp__github__list_dependabot_alerts
          # - mcp__github__list_discussion_categories
          # - mcp__github__list_discussions
          # - mcp__github__list_issues
          # - mcp__github__list_notifications
          # - mcp__github__list_pull_requests
          # - mcp__github__list_secret_scanning_alerts
          # - mcp__github__list_tags
          # - mcp__github__list_workflow_jobs
          # - mcp__github__list_workflow_run_artifacts
          # - mcp__github__list_workflow_runs
          # - mcp__github__list_workflows
          # - mcp__github__search_code
          # - mcp__github__search_issues
          # - mcp__github__search_orgs
          # - mcp__github__search_pull_requests
          # - mcp__github__search_repositories
          # - mcp__github__search_users
          allowed_tools: "ExitPlanMode,Glob,Grep,LS,NotebookRead,Read,Task,TodoWrite,WebFetch,WebSearch,mcp__github__download_workflow_run_artifact,mcp__github__get_code_scanning_alert,mcp__github__get_commit,mcp__github__get_dependabot_alert,mcp__github__get_discussion,mcp__github__get_discussion_comments,mcp__github__get_file_contents,mcp__github__get_issue,mcp__github__get_issue_comments,mcp__github__get_job_logs,mcp__github__get_me,mcp__github__get_notification_details,mcp__github__get_pull_request,mcp__github__get_pull_request_comments,mcp__github__get_pull_request_diff,mcp__github__get_pull_request_files,mcp__github__get_pull_request_reviews,mcp__github__get_pull_request_status,mcp__github__get_secret_scanning_alert,mcp__github__get_tag,mcp__github__get_workflow_run,mcp__github__get_workflow_run_logs,mcp__github__get_workflow_run_usage,mcp__github__list_branches,mcp__github__list_code_scanning_alerts,mcp__github__list_commits,mcp__github__list_dependabot_alerts,mcp__github__list_discussion_categories,mcp__github__list_discussions,mcp__github__list_issues,mcp__github__list_notifications,mcp__github__list_pull_requests,mcp__github__list_secret_scanning_alerts,mcp__github__list_tags,mcp__github__list_workflow_jobs,mcp__github__list_workflow_run_artifacts,mcp__github__list_workflow_runs,mcp__github__list_workflows,mcp__github__search_code,mcp__github__search_issues,mcp__github__search_orgs,mcp__github__search_pull_requests,mcp__github__search_repositories,mcp__github__search_users"
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          mcp_config: /tmp/mcp-config/mcp-servers.json
          prompt_file: /tmp/aw-prompts/prompt.txt
          settings: /tmp/.claude/settings.json
          timeout_minutes: 5
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
      - name: Capture Agentic Action logs
        if: always()
        run: |
          # Copy the detailed execution file from Agentic Action if available
          if [ -n "${{ steps.agentic_execution.outputs.execution_file }}" ] && [ -f "${{ steps.agentic_execution.outputs.execution_file }}" ]; then
            cp ${{ steps.agentic_execution.outputs.execution_file }} /tmp/secure-web-research-task.log
          else
            echo "No execution file output found from Agentic Action" >> /tmp/secure-web-research-task.log
          fi
          
          # Ensure log file exists
          touch /tmp/secure-web-research-task.log
      - name: Upload engine output files
        uses: actions/upload-artifact@v4
        with:
          name: agent_outputs
          path: |
            output.txt
          if-no-files-found: ignore
      - name: Clean up engine output files
        run: |
          rm -f output.txt
      - name: Parse agent logs for step summary
        if: always()
        uses: actions/github-script@v7
        env:
          GITHUB_AW_AGENT_OUTPUT: /tmp/secure-web-research-task.log
        with:
          script: |
            function main() {
              const fs = require("fs");
              try {
                // Get the log file path from environment
                const logFile = process.env.GITHUB_AW_AGENT_OUTPUT;
                if (!logFile) {
                  core.info("No agent log file specified");
                  return;
                }
                if (!fs.existsSync(logFile)) {
                  core.info(`Log file not found: ${logFile}`);
                  return;
                }
                const logContent = fs.readFileSync(logFile, "utf8");
                const result = parseClaudeLog(logContent);
                // Append to GitHub step summary
                core.summary.addRaw(result.markdown).write();
                // Check for MCP server failures and fail the job if any occurred
                if (result.mcpFailures && result.mcpFailures.length > 0) {
                  const failedServers = result.mcpFailures.join(", ");
                  core.setFailed(`MCP server(s) failed to launch: ${failedServers}`);
                }
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                core.setFailed(errorMessage);
              }
            }
            /**
             * Parses Claude log content and converts it to markdown format
             * @param {string} logContent - The raw log content as a string
             * @returns {{markdown: string, mcpFailures: string[]}} Result with formatted markdown content and MCP failure list
             */
            function parseClaudeLog(logContent) {
              try {
                const logEntries = JSON.parse(logContent);
                if (!Array.isArray(logEntries)) {
                  return {
                    markdown:
                      "## Agent Log Summary\n\nLog format not recognized as Claude JSON array.\n",
                    mcpFailures: [],
                  };
                }
                let markdown = "";
                const mcpFailures = [];
                // Check for initialization data first
                const initEntry = logEntries.find(
                  entry => entry.type === "system" && entry.subtype === "init"
                );
                if (initEntry) {
                  markdown += "## 🚀 Initialization\n\n";
                  const initResult = formatInitializationSummary(initEntry);
                  markdown += initResult.markdown;
                  mcpFailures.push(...initResult.mcpFailures);
                  markdown += "\n";
                }
                markdown += "## 🤖 Commands and Tools\n\n";
                const toolUsePairs = new Map(); // Map tool_use_id to tool_result
                const commandSummary = []; // For the succinct summary
                // First pass: collect tool results by tool_use_id
                for (const entry of logEntries) {
                  if (entry.type === "user" && entry.message?.content) {
                    for (const content of entry.message.content) {
                      if (content.type === "tool_result" && content.tool_use_id) {
                        toolUsePairs.set(content.tool_use_id, content);
                      }
                    }
                  }
                }
                // Collect all tool uses for summary
                for (const entry of logEntries) {
                  if (entry.type === "assistant" && entry.message?.content) {
                    for (const content of entry.message.content) {
                      if (content.type === "tool_use") {
                        const toolName = content.name;
                        const input = content.input || {};
                        // Skip internal tools - only show external commands and API calls
                        if (
                          [
                            "Read",
                            "Write",
                            "Edit",
                            "MultiEdit",
                            "LS",
                            "Grep",
                            "Glob",
                            "TodoWrite",
                          ].includes(toolName)
                        ) {
                          continue; // Skip internal file operations and searches
                        }
                        // Find the corresponding tool result to get status
                        const toolResult = toolUsePairs.get(content.id);
                        let statusIcon = "❓";
                        if (toolResult) {
                          statusIcon = toolResult.is_error === true ? "❌" : "✅";
                        }
                        // Add to command summary (only external tools)
                        if (toolName === "Bash") {
                          const formattedCommand = formatBashCommand(input.command || "");
                          commandSummary.push(`* ${statusIcon} \`${formattedCommand}\``);
                        } else if (toolName.startsWith("mcp__")) {
                          const mcpName = formatMcpName(toolName);
                          commandSummary.push(`* ${statusIcon} \`${mcpName}(...)\``);
                        } else {
                          // Handle other external tools (if any)
                          commandSummary.push(`* ${statusIcon} ${toolName}`);
                        }
                      }
                    }
                  }
                }
                // Add command summary
                if (commandSummary.length > 0) {
                  for (const cmd of commandSummary) {
                    markdown += `${cmd}\n`;
                  }
                } else {
                  markdown += "No commands or tools used.\n";
                }
                // Add Information section from the last entry with result metadata
                markdown += "\n## 📊 Information\n\n";
                // Find the last entry with metadata
                const lastEntry = logEntries[logEntries.length - 1];
                if (
                  lastEntry &&
                  (lastEntry.num_turns ||
                    lastEntry.duration_ms ||
                    lastEntry.total_cost_usd ||
                    lastEntry.usage)
                ) {
                  if (lastEntry.num_turns) {
                    markdown += `**Turns:** ${lastEntry.num_turns}\n\n`;
                  }
                  if (lastEntry.duration_ms) {
                    const durationSec = Math.round(lastEntry.duration_ms / 1000);
                    const minutes = Math.floor(durationSec / 60);
                    const seconds = durationSec % 60;
                    markdown += `**Duration:** ${minutes}m ${seconds}s\n\n`;
                  }
                  if (lastEntry.total_cost_usd) {
                    markdown += `**Total Cost:** $${lastEntry.total_cost_usd.toFixed(4)}\n\n`;
                  }
                  if (lastEntry.usage) {
                    const usage = lastEntry.usage;
                    if (usage.input_tokens || usage.output_tokens) {
                      markdown += `**Token Usage:**\n`;
                      if (usage.input_tokens)
                        markdown += `- Input: ${usage.input_tokens.toLocaleString()}\n`;
                      if (usage.cache_creation_input_tokens)
                        markdown += `- Cache Creation: ${usage.cache_creation_input_tokens.toLocaleString()}\n`;
                      if (usage.cache_read_input_tokens)
                        markdown += `- Cache Read: ${usage.cache_read_input_tokens.toLocaleString()}\n`;
                      if (usage.output_tokens)
                        markdown += `- Output: ${usage.output_tokens.toLocaleString()}\n`;
                      markdown += "\n";
                    }
                  }
                  if (
                    lastEntry.permission_denials &&
                    lastEntry.permission_denials.length > 0
                  ) {
                    markdown += `**Permission Denials:** ${lastEntry.permission_denials.length}\n\n`;
                  }
                }
                markdown += "\n## 🤖 Reasoning\n\n";
                // Second pass: process assistant messages in sequence
                for (const entry of logEntries) {
                  if (entry.type === "assistant" && entry.message?.content) {
                    for (const content of entry.message.content) {
                      if (content.type === "text" && content.text) {
                        // Add reasoning text directly (no header)
                        const text = content.text.trim();
                        if (text && text.length > 0) {
                          markdown += text + "\n\n";
                        }
                      } else if (content.type === "tool_use") {
                        // Process tool use with its result
                        const toolResult = toolUsePairs.get(content.id);
                        const toolMarkdown = formatToolUse(content, toolResult);
                        if (toolMarkdown) {
                          markdown += toolMarkdown;
                        }
                      }
                    }
                  }
                }
                return { markdown, mcpFailures };
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                return {
                  markdown: `## Agent Log Summary\n\nError parsing Claude log: ${errorMessage}\n`,
                  mcpFailures: [],
                };
              }
            }
            /**
             * Formats initialization information from system init entry
             * @param {any} initEntry - The system init entry containing tools, mcp_servers, etc.
             * @returns {{markdown: string, mcpFailures: string[]}} Result with formatted markdown string and MCP failure list
             */
            function formatInitializationSummary(initEntry) {
              let markdown = "";
              const mcpFailures = [];
              // Display model and session info
              if (initEntry.model) {
                markdown += `**Model:** ${initEntry.model}\n\n`;
              }
              if (initEntry.session_id) {
                markdown += `**Session ID:** ${initEntry.session_id}\n\n`;
              }
              if (initEntry.cwd) {
                // Show a cleaner path by removing common prefixes
                const cleanCwd = initEntry.cwd.replace(
                  /^\/home\/runner\/work\/[^\/]+\/[^\/]+/,
                  "."
                );
                markdown += `**Working Directory:** ${cleanCwd}\n\n`;
              }
              // Display MCP servers status
              if (initEntry.mcp_servers && Array.isArray(initEntry.mcp_servers)) {
                markdown += "**MCP Servers:**\n";
                for (const server of initEntry.mcp_servers) {
                  const statusIcon =
                    server.status === "connected"
                      ? "✅"
                      : server.status === "failed"
                        ? "❌"
                        : "❓";
                  markdown += `- ${statusIcon} ${server.name} (${server.status})\n`;
                  // Track failed MCP servers
                  if (server.status === "failed") {
                    mcpFailures.push(server.name);
                  }
                }
                markdown += "\n";
              }
              // Display tools by category
              if (initEntry.tools && Array.isArray(initEntry.tools)) {
                markdown += "**Available Tools:**\n";
                // Categorize tools
                /** @type {{ [key: string]: string[] }} */
                const categories = {
                  Core: [],
                  "File Operations": [],
                  "Git/GitHub": [],
                  MCP: [],
                  Other: [],
                };
                for (const tool of initEntry.tools) {
                  if (
                    ["Task", "Bash", "BashOutput", "KillBash", "ExitPlanMode"].includes(
                      tool
                    )
                  ) {
                    categories["Core"].push(tool);
                  } else if (
                    [
                      "Read",
                      "Edit",
                      "MultiEdit",
                      "Write",
                      "LS",
                      "Grep",
                      "Glob",
                      "NotebookEdit",
                    ].includes(tool)
                  ) {
                    categories["File Operations"].push(tool);
                  } else if (tool.startsWith("mcp__github__")) {
                    categories["Git/GitHub"].push(formatMcpName(tool));
                  } else if (
                    tool.startsWith("mcp__") ||
                    ["ListMcpResourcesTool", "ReadMcpResourceTool"].includes(tool)
                  ) {
                    categories["MCP"].push(
                      tool.startsWith("mcp__") ? formatMcpName(tool) : tool
                    );
                  } else {
                    categories["Other"].push(tool);
                  }
                }
                // Display categories with tools
                for (const [category, tools] of Object.entries(categories)) {
                  if (tools.length > 0) {
                    markdown += `- **${category}:** ${tools.length} tools\n`;
                    if (tools.length <= 5) {
                      // Show all tools if 5 or fewer
                      markdown += `  - ${tools.join(", ")}\n`;
                    } else {
                      // Show first few and count
                      markdown += `  - ${tools.slice(0, 3).join(", ")}, and ${tools.length - 3} more\n`;
                    }
                  }
                }
                markdown += "\n";
              }
              // Display slash commands if available
              if (initEntry.slash_commands && Array.isArray(initEntry.slash_commands)) {
                const commandCount = initEntry.slash_commands.length;
                markdown += `**Slash Commands:** ${commandCount} available\n`;
                if (commandCount <= 10) {
                  markdown += `- ${initEntry.slash_commands.join(", ")}\n`;
                } else {
                  markdown += `- ${initEntry.slash_commands.slice(0, 5).join(", ")}, and ${commandCount - 5} more\n`;
                }
                markdown += "\n";
              }
              return { markdown, mcpFailures };
            }
            /**
             * Formats a tool use entry with its result into markdown
             * @param {any} toolUse - The tool use object containing name, input, etc.
             * @param {any} toolResult - The corresponding tool result object
             * @returns {string} Formatted markdown string
             */
            function formatToolUse(toolUse, toolResult) {
              const toolName = toolUse.name;
              const input = toolUse.input || {};
              // Skip TodoWrite except the very last one (we'll handle this separately)
              if (toolName === "TodoWrite") {
                return ""; // Skip for now, would need global context to find the last one
              }
              // Helper function to determine status icon
              function getStatusIcon() {
                if (toolResult) {
                  return toolResult.is_error === true ? "❌" : "✅";
                }
                return "❓"; // Unknown by default
              }
              let markdown = "";
              const statusIcon = getStatusIcon();
              switch (toolName) {
                case "Bash":
                  const command = input.command || "";
                  const description = input.description || "";
                  // Format the command to be single line
                  const formattedCommand = formatBashCommand(command);
                  if (description) {
                    markdown += `${description}:\n\n`;
                  }
                  markdown += `${statusIcon} \`${formattedCommand}\`\n\n`;
                  break;
                case "Read":
                  const filePath = input.file_path || input.path || "";
                  const relativePath = filePath.replace(
                    /^\/[^\/]*\/[^\/]*\/[^\/]*\/[^\/]*\//,
                    ""
                  ); // Remove /home/runner/work/repo/repo/ prefix
                  markdown += `${statusIcon} Read \`${relativePath}\`\n\n`;
                  break;
                case "Write":
                case "Edit":
                case "MultiEdit":
                  const writeFilePath = input.file_path || input.path || "";
                  const writeRelativePath = writeFilePath.replace(
                    /^\/[^\/]*\/[^\/]*\/[^\/]*\/[^\/]*\//,
                    ""
                  );
                  markdown += `${statusIcon} Write \`${writeRelativePath}\`\n\n`;
                  break;
                case "Grep":
                case "Glob":
                  const query = input.query || input.pattern || "";
                  markdown += `${statusIcon} Search for \`${truncateString(query, 80)}\`\n\n`;
                  break;
                case "LS":
                  const lsPath = input.path || "";
                  const lsRelativePath = lsPath.replace(
                    /^\/[^\/]*\/[^\/]*\/[^\/]*\/[^\/]*\//,
                    ""
                  );
                  markdown += `${statusIcon} LS: ${lsRelativePath || lsPath}\n\n`;
                  break;
                default:
                  // Handle MCP calls and other tools
                  if (toolName.startsWith("mcp__")) {
                    const mcpName = formatMcpName(toolName);
                    const params = formatMcpParameters(input);
                    markdown += `${statusIcon} ${mcpName}(${params})\n\n`;
                  } else {
                    // Generic tool formatting - show the tool name and main parameters
                    const keys = Object.keys(input);
                    if (keys.length > 0) {
                      // Try to find the most important parameter
                      const mainParam =
                        keys.find(k =>
                          ["query", "command", "path", "file_path", "content"].includes(k)
                        ) || keys[0];
                      const value = String(input[mainParam] || "");
                      if (value) {
                        markdown += `${statusIcon} ${toolName}: ${truncateString(value, 100)}\n\n`;
                      } else {
                        markdown += `${statusIcon} ${toolName}\n\n`;
                      }
                    } else {
                      markdown += `${statusIcon} ${toolName}\n\n`;
                    }
                  }
              }
              return markdown;
            }
            /**
             * Formats MCP tool name from internal format to display format
             * @param {string} toolName - The raw tool name (e.g., mcp__github__search_issues)
             * @returns {string} Formatted tool name (e.g., github::search_issues)
             */
            function formatMcpName(toolName) {
              // Convert mcp__github__search_issues to github::search_issues
              if (toolName.startsWith("mcp__")) {
                const parts = toolName.split("__");
                if (parts.length >= 3) {
                  const provider = parts[1]; // github, etc.
                  const method = parts.slice(2).join("_"); // search_issues, etc.
                  return `${provider}::${method}`;
                }
              }
              return toolName;
            }
            /**
             * Formats MCP parameters into a human-readable string
             * @param {Record<string, any>} input - The input object containing parameters
             * @returns {string} Formatted parameters string
             */
            function formatMcpParameters(input) {
              const keys = Object.keys(input);
              if (keys.length === 0) return "";
              const paramStrs = [];
              for (const key of keys.slice(0, 4)) {
                // Show up to 4 parameters
                const value = String(input[key] || "");
                paramStrs.push(`${key}: ${truncateString(value, 40)}`);
              }
              if (keys.length > 4) {
                paramStrs.push("...");
              }
              return paramStrs.join(", ");
            }
            /**
             * Formats a bash command by normalizing whitespace and escaping
             * @param {string} command - The raw bash command string
             * @returns {string} Formatted and escaped command string
             */
            function formatBashCommand(command) {
              if (!command) return "";
              // Convert multi-line commands to single line by replacing newlines with spaces
              // and collapsing multiple spaces
              let formatted = command
                .replace(/\n/g, " ") // Replace newlines with spaces
                .replace(/\r/g, " ") // Replace carriage returns with spaces
                .replace(/\t/g, " ") // Replace tabs with spaces
                .replace(/\s+/g, " ") // Collapse multiple spaces into one
                .trim(); // Remove leading/trailing whitespace
              // Escape backticks to prevent markdown issues
              formatted = formatted.replace(/`/g, "\\`");
              // Truncate if too long (keep reasonable length for summary)
              const maxLength = 80;
              if (formatted.length > maxLength) {
                formatted = formatted.substring(0, maxLength) + "...";
              }
              return formatted;
            }
            /**
             * Truncates a string to a maximum length with ellipsis
             * @param {string} str - The string to truncate
             * @param {number} maxLength - Maximum allowed length
             * @returns {string} Truncated string with ellipsis if needed
             */
            function truncateString(str, maxLength) {
              if (!str) return "";
              if (str.length <= maxLength) return str;
              return str.substring(0, maxLength) + "...";
            }
            // Export for testing
            if (typeof module !== "undefined" && module.exports) {
              module.exports = {
                parseClaudeLog,
                formatToolUse,
                formatInitializationSummary,
                formatBashCommand,
                truncateString,
              };
            }
            main();
      - name: Upload agent logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: secure-web-research-task.log
          path: /tmp/secure-web-research-task.log
          if-no-files-found: warn

