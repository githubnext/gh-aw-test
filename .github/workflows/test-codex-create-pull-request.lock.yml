# This file was automatically generated by gh-aw. DO NOT EDIT.
# To update this file, edit the corresponding .md file and run:
#   gh aw compile

name: "Test Codex Create Pull Request"
on:
  workflow_dispatch: null

permissions: {}

concurrency:
  group: "gh-aw-${{ github.workflow }}"

run-name: "Test Codex Create Pull Request"

jobs:
  test-codex-create-pull-request:
    runs-on: ubuntu-latest
    permissions: read-all
    outputs:
      output: ${{ steps.collect_output.outputs.output }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
      - name: Configure Git credentials
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "${{ github.workflow }}"
          echo "Git configured with standard GitHub Actions identity"
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
      - name: Install Codex
        run: npm install -g @openai/codex
      - name: Setup agent output
        id: setup_agent_output
        uses: actions/github-script@v8
        with:
          script: |
            function main() {
              const fs = require("fs");
              const crypto = require("crypto");
              // Generate a random filename for the output file
              const randomId = crypto.randomBytes(8).toString("hex");
              const outputFile = `/tmp/aw_output_${randomId}.txt`;
              // Ensure the /tmp directory exists
              fs.mkdirSync("/tmp", { recursive: true });
              // We don't create the file, as the name is sufficiently random
              // and some engines (Claude) fails first Write to the file
              // if it exists and has not been read.
              // Set the environment variable for subsequent steps
              core.exportVariable("GITHUB_AW_SAFE_OUTPUTS", outputFile);
              // Also set as step output for reference
              core.setOutput("output_file", outputFile);
            }
            main();
      - name: Setup Safe Outputs Collector MCP
        env:
          GITHUB_AW_SAFE_OUTPUTS_CONFIG: "{\"create-pull-request\":{}}"
        run: |
          mkdir -p /tmp/safe-outputs
          cat > /tmp/safe-outputs/mcp-server.cjs << 'EOF'
            const fs = require("fs");
            const encoder = new TextEncoder();
            const configEnv = process.env.GITHUB_AW_SAFE_OUTPUTS_CONFIG;
            if (!configEnv) throw new Error("GITHUB_AW_SAFE_OUTPUTS_CONFIG not set");
            const safeOutputsConfig = JSON.parse(configEnv);
            const outputFile = process.env.GITHUB_AW_SAFE_OUTPUTS;
            if (!outputFile)
              throw new Error("GITHUB_AW_SAFE_OUTPUTS not set, no output file");
            const SERVER_INFO = { name: "safe-outputs-mcp-server", version: "1.0.0" };
            const debug = msg => process.stderr.write(`[${SERVER_INFO.name}] ${msg}\n`);
            function writeMessage(obj) {
              const json = JSON.stringify(obj);
              debug(`send: ${json}`);
              const message = json + "\n";
              const bytes = encoder.encode(message);
              fs.writeSync(1, bytes);
            }
            class ReadBuffer {
              append(chunk) {
                this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
              }
              readMessage() {
                if (!this._buffer) {
                  return null;
                }
                const index = this._buffer.indexOf("\n");
                if (index === -1) {
                  return null;
                }
                const line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
                this._buffer = this._buffer.subarray(index + 1);
                if (line.trim() === "") {
                  return this.readMessage(); // Skip empty lines recursively
                }
                try {
                  return JSON.parse(line);
                } catch (error) {
                  throw new Error(
                    `Parse error: ${error instanceof Error ? error.message : String(error)}`
                  );
                }
              }
            }
            const readBuffer = new ReadBuffer();
            function onData(chunk) {
              readBuffer.append(chunk);
              processReadBuffer();
            }
            function processReadBuffer() {
              while (true) {
                try {
                  const message = readBuffer.readMessage();
                  if (!message) {
                    break;
                  }
                  debug(`recv: ${JSON.stringify(message)}`);
                  handleMessage(message);
                } catch (error) {
                  // For parse errors, we can't know the request id, so we shouldn't send a response
                  // according to JSON-RPC spec. Just log the error.
                  debug(
                    `Parse error: ${error instanceof Error ? error.message : String(error)}`
                  );
                }
              }
            }
            function replyResult(id, result) {
              if (id === undefined || id === null) return; // notification
              const res = { jsonrpc: "2.0", id, result };
              writeMessage(res);
            }
            function replyError(id, code, message, data) {
              // Don't send error responses for notifications (id is null/undefined)
              if (id === undefined || id === null) {
                debug(`Error for notification: ${message}`);
                return;
              }
              const error = { code, message };
              if (data !== undefined) {
                error.data = data;
              }
              const res = {
                jsonrpc: "2.0",
                id,
                error,
              };
              writeMessage(res);
            }
            function isToolEnabled(name) {
              return safeOutputsConfig[name];
            }
            function appendSafeOutput(entry) {
              if (!outputFile) throw new Error("No output file configured");
              const jsonLine = JSON.stringify(entry) + "\n";
              try {
                fs.appendFileSync(outputFile, jsonLine);
              } catch (error) {
                throw new Error(
                  `Failed to write to output file: ${error instanceof Error ? error.message : String(error)}`
                );
              }
            }
            const defaultHandler = type => args => {
              const entry = { ...(args || {}), type };
              appendSafeOutput(entry);
              return {
                content: [
                  {
                    type: "text",
                    text: `success`,
                  },
                ],
              };
            };
            const TOOLS = Object.fromEntries(
              [
                {
                  name: "create-issue",
                  description: "Create a new GitHub issue",
                  inputSchema: {
                    type: "object",
                    required: ["title", "body"],
                    properties: {
                      title: { type: "string", description: "Issue title" },
                      body: { type: "string", description: "Issue body/description" },
                      labels: {
                        type: "array",
                        items: { type: "string" },
                        description: "Issue labels",
                      },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "create-discussion",
                  description: "Create a new GitHub discussion",
                  inputSchema: {
                    type: "object",
                    required: ["title", "body"],
                    properties: {
                      title: { type: "string", description: "Discussion title" },
                      body: { type: "string", description: "Discussion body/content" },
                      category: { type: "string", description: "Discussion category" },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "add-comment",
                  description: "Add a comment to a GitHub issue or pull request",
                  inputSchema: {
                    type: "object",
                    required: ["body"],
                    properties: {
                      body: { type: "string", description: "Comment body/content" },
                      issue_number: {
                        type: "number",
                        description: "Issue or PR number (optional for current context)",
                      },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "create-pull-request",
                  description: "Create a new GitHub pull request",
                  inputSchema: {
                    type: "object",
                    required: ["title", "body", "branch"],
                    properties: {
                      title: { type: "string", description: "Pull request title" },
                      body: {
                        type: "string",
                        description: "Pull request body/description",
                      },
                      branch: {
                        type: "string",
                        description: "Required branch name",
                      },
                      labels: {
                        type: "array",
                        items: { type: "string" },
                        description: "Optional labels to add to the PR",
                      },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "create-pull-request-review-comment",
                  description: "Create a review comment on a GitHub pull request",
                  inputSchema: {
                    type: "object",
                    required: ["path", "line", "body"],
                    properties: {
                      path: {
                        type: "string",
                        description: "File path for the review comment",
                      },
                      line: {
                        type: ["number", "string"],
                        description: "Line number for the comment",
                      },
                      body: { type: "string", description: "Comment body content" },
                      start_line: {
                        type: ["number", "string"],
                        description: "Optional start line for multi-line comments",
                      },
                      side: {
                        type: "string",
                        enum: ["LEFT", "RIGHT"],
                        description: "Optional side of the diff: LEFT or RIGHT",
                      },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "create-code-scanning-alert",
                  description: "Create a code scanning alert",
                  inputSchema: {
                    type: "object",
                    required: ["file", "line", "severity", "message"],
                    properties: {
                      file: {
                        type: "string",
                        description: "File path where the issue was found",
                      },
                      line: {
                        type: ["number", "string"],
                        description: "Line number where the issue was found",
                      },
                      severity: {
                        type: "string",
                        enum: ["error", "warning", "info", "note"],
                        description: "Severity level",
                      },
                      message: {
                        type: "string",
                        description: "Alert message describing the issue",
                      },
                      column: {
                        type: ["number", "string"],
                        description: "Optional column number",
                      },
                      ruleIdSuffix: {
                        type: "string",
                        description: "Optional rule ID suffix for uniqueness",
                      },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "add-labels",
                  description: "Add labels to a GitHub issue or pull request",
                  inputSchema: {
                    type: "object",
                    required: ["labels"],
                    properties: {
                      labels: {
                        type: "array",
                        items: { type: "string" },
                        description: "Labels to add",
                      },
                      issue_number: {
                        type: "number",
                        description: "Issue or PR number (optional for current context)",
                      },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "update-issue",
                  description: "Update a GitHub issue",
                  inputSchema: {
                    type: "object",
                    properties: {
                      status: {
                        type: "string",
                        enum: ["open", "closed"],
                        description: "Optional new issue status",
                      },
                      title: { type: "string", description: "Optional new issue title" },
                      body: { type: "string", description: "Optional new issue body" },
                      issue_number: {
                        type: ["number", "string"],
                        description: "Optional issue number for target '*'",
                      },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "push-to-pr-branch",
                  description: "Push changes to a pull request branch",
                  inputSchema: {
                    type: "object",
                    required: ["branch", "message"],
                    properties: {
                      branch: {
                        type: "string",
                        description:
                          "The name of the branch to push to, should be the branch name associated with the pull request",
                      },
                      message: { type: "string", description: "Commit message" },
                      pull_request_number: {
                        type: ["number", "string"],
                        description: "Optional pull request number for target '*'",
                      },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "missing-tool",
                  description:
                    "Report a missing tool or functionality needed to complete tasks",
                  inputSchema: {
                    type: "object",
                    required: ["tool", "reason"],
                    properties: {
                      tool: { type: "string", description: "Name of the missing tool" },
                      reason: { type: "string", description: "Why this tool is needed" },
                      alternatives: {
                        type: "string",
                        description: "Possible alternatives or workarounds",
                      },
                    },
                    additionalProperties: false,
                  },
                },
              ]
                .filter(({ name }) => isToolEnabled(name))
                .map(tool => [tool.name, tool])
            );
            debug(`v${SERVER_INFO.version} ready on stdio`);
            debug(`  output file: ${outputFile}`);
            debug(`  config: ${JSON.stringify(safeOutputsConfig)}`);
            debug(`  tools: ${Object.keys(TOOLS).join(", ")}`);
            if (!Object.keys(TOOLS).length)
              throw new Error("No tools enabled in configuration");
            function handleMessage(req) {
              // Validate basic JSON-RPC structure
              if (!req || typeof req !== "object") {
                debug(`Invalid message: not an object`);
                return;
              }
              if (req.jsonrpc !== "2.0") {
                debug(`Invalid message: missing or invalid jsonrpc field`);
                return;
              }
              const { id, method, params } = req;
              // Validate method field
              if (!method || typeof method !== "string") {
                replyError(id, -32600, "Invalid Request: method must be a string");
                return;
              }
              try {
                if (method === "initialize") {
                  const clientInfo = params?.clientInfo ?? {};
                  console.error(`client initialized:`, clientInfo);
                  const protocolVersion = params?.protocolVersion ?? undefined;
                  const result = {
                    serverInfo: SERVER_INFO,
                    ...(protocolVersion ? { protocolVersion } : {}),
                    capabilities: {
                      tools: {},
                    },
                  };
                  replyResult(id, result);
                } else if (method === "tools/list") {
                  const list = [];
                  Object.values(TOOLS).forEach(tool => {
                    list.push({
                      name: tool.name,
                      description: tool.description,
                      inputSchema: tool.inputSchema,
                    });
                  });
                  replyResult(id, { tools: list });
                } else if (method === "tools/call") {
                  const name = params?.name;
                  const args = params?.arguments ?? {};
                  if (!name || typeof name !== "string") {
                    replyError(id, -32602, "Invalid params: 'name' must be a string");
                    return;
                  }
                  const tool = TOOLS[name];
                  if (!tool) {
                    replyError(id, -32601, `Tool not found: ${name}`);
                    return;
                  }
                  const handler = tool.handler || defaultHandler(tool.name);
                  const requiredFields =
                    tool.inputSchema && Array.isArray(tool.inputSchema.required)
                      ? tool.inputSchema.required
                      : [];
                  if (requiredFields.length) {
                    const missing = requiredFields.filter(f => {
                      const value = args[f];
                      return (
                        value === undefined ||
                        value === null ||
                        (typeof value === "string" && value.trim() === "")
                      );
                    });
                    if (missing.length) {
                      replyError(
                        id,
                        -32602,
                        `Invalid arguments: missing or empty ${missing.map(m => `'${m}'`).join(", ")}`
                      );
                      return;
                    }
                  }
                  const result = handler(args);
                  const content = result && result.content ? result.content : [];
                  replyResult(id, { content });
                } else if (/^notifications\//.test(method)) {
                  debug(`ignore ${method}`);
                } else {
                  replyError(id, -32601, `Method not found: ${method}`);
                }
              } catch (e) {
                replyError(id, -32603, "Internal error", {
                  message: e instanceof Error ? e.message : String(e),
                });
              }
            }
            process.stdin.on("data", onData);
            process.stdin.on("error", err => debug(`stdin error: ${err}`));
            process.stdin.resume();
            debug(`listening...`);
          EOF
          chmod +x /tmp/safe-outputs/mcp-server.cjs
          
      - name: Setup MCPs
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_AW_SAFE_OUTPUTS_CONFIG: "{\"create-pull-request\":{}}"
        run: |
          mkdir -p /tmp/mcp-config
          cat > /tmp/mcp-config/config.toml << EOF
          [history]
          persistence = "none"
          
          [mcp_servers.github]
          user_agent = "test-codex-create-pull-request"
          command = "docker"
          args = [
            "run",
            "-i",
            "--rm",
            "-e",
            "GITHUB_PERSONAL_ACCESS_TOKEN",
            "ghcr.io/github/github-mcp-server:sha-09deac4"
          ]
          env = { "GITHUB_PERSONAL_ACCESS_TOKEN" = "${{ secrets.GITHUB_TOKEN }}" }
          
          [mcp_servers.safe_outputs]
          command = "node"
          args = [
            "/tmp/safe-outputs/mcp-server.cjs",
          ]
          env = { "GITHUB_AW_SAFE_OUTPUTS" = "${{ env.GITHUB_AW_SAFE_OUTPUTS }}", "GITHUB_AW_SAFE_OUTPUTS_CONFIG" = ${{ toJSON(env.GITHUB_AW_SAFE_OUTPUTS_CONFIG) }} }
          EOF
      - name: Create prompt
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
        run: |
          mkdir -p /tmp/aw-prompts
          cat > $GITHUB_AW_PROMPT << 'EOF'
          # Test Codex Create Pull Request
          
          This test workflow specifically tests multi-commit functionality in create-pull-request.
          
          **IMPORTANT: Create multiple separate commits for this test case**
          
          1. **First commit**: Create a file "README-test.md" with content:
             ```markdown
             # Test Project
             
             This is a test project created by Codex to test multi-commit pull requests.
             
             Created at: {{ current timestamp }}
             ```
          
          2. **Second commit**: Create a JavaScript script "test-script.js" with:
             ```javascript
             #!/usr/bin/env node
             function hello() {
                 console.log("Hello from Codex multi-commit test!");
             }
             
             if (require.main === module) {
                 hello();
             }
             ```
          
          3. **Third commit**: Create a configuration file "config.json" with:
             ```json
             {
                 "test": true,
                 "engine": "codex",
                 "purpose": "multi-commit-test",
                 "timestamp": "{{ current timestamp }}"
             }
             ```
          
          4. **Fourth commit**: Create a log file "test.log" containing the current time. This is just a log file.
          
          Create a pull request with title "Multi-commit test from Codex" and body:
          ```markdown
          # Multi-Commit Test Pull Request
          
          This PR was created by Codex to test the multi-commit functionality in agentic workflows.
          
          ## Changes Made
          
          This PR contains exactly 4 commits:
          1. Added README-test.md with project description
          2. Added test-script.js with JavaScript hello function
          3. Added config.json with test configuration
          4. Added test.log with timestamp
          
          Each change was made in a separate commit to test that `git am` properly applies all commits from the patch file, not just the first one.
          
          ## Haiku about Multi-Commits
          
          Git commits aligned,  
          Each change builds upon the last—  
          Patch preserves them all.
          ```
          
          
          ---
          
          ## Creating a Pull RequestReporting Missing Tools or Functionality
          
          **IMPORTANT**: To do the actions mentioned in the header of this section, use the **safe-outputs** tools, do NOT attempt to use `gh`, do NOT attempt to use the GitHub API. You don't have write access to the GitHub repo.
          
          **Creating a Pull Request**
          
          To create a pull request:
          1. Make any file changes directly in the working directory
          2. If you haven't done so already, create a local branch using an appropriate unique name
          3. Add and commit your changes to the branch. Be careful to add exactly the files you intend, and check there are no extra files left un-added. Check you haven't deleted or changed any files you didn't intend to.
          4. Do not push your changes. That will be done by the tool.
          5. Create the pull request with the create-pull-request tool from the safe-outputs MCP
          
          EOF
      - name: Print prompt to step summary
        run: |
          echo "## Generated Prompt" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````markdown' >> $GITHUB_STEP_SUMMARY
          cat $GITHUB_AW_PROMPT >> $GITHUB_STEP_SUMMARY
          echo '``````' >> $GITHUB_STEP_SUMMARY
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
      - name: Generate agentic run info
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            
            const awInfo = {
              engine_id: "codex",
              engine_name: "Codex",
              model: "",
              version: "",
              workflow_name: "Test Codex Create Pull Request",
              experimental: true,
              supports_tools_whitelist: true,
              supports_http_transport: false,
              run_id: context.runId,
              run_number: context.runNumber,
              run_attempt: process.env.GITHUB_RUN_ATTEMPT,
              repository: context.repo.owner + '/' + context.repo.repo,
              ref: context.ref,
              sha: context.sha,
              actor: context.actor,
              event_name: context.eventName,
              staged: false,
              created_at: new Date().toISOString()
            };
            
            // Write to /tmp directory to avoid inclusion in PR
            const tmpPath = '/tmp/aw_info.json';
            fs.writeFileSync(tmpPath, JSON.stringify(awInfo, null, 2));
            console.log('Generated aw_info.json at:', tmpPath);
            console.log(JSON.stringify(awInfo, null, 2));
            
            // Add agentic workflow run information to step summary
            core.summary
              .addRaw('## Agentic Run Information\n\n')
              .addRaw('```json\n')
              .addRaw(JSON.stringify(awInfo, null, 2))
              .addRaw('\n```\n')
              .write();
      - name: Upload agentic run info
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: aw_info.json
          path: /tmp/aw_info.json
          if-no-files-found: warn
      - name: Run Codex
        run: |
          set -o pipefail
          INSTRUCTION=$(cat /tmp/aw-prompts/prompt.txt)
          export CODEX_HOME=/tmp/mcp-config
          
          # Create log directory outside git repo
          mkdir -p /tmp/aw-logs
          
          # where is Codex
          which codex
          
          # Check Codex version
          codex --version
          
          # Authenticate with Codex
          codex login --api-key "$OPENAI_API_KEY"
          
          # Run codex with log capture - pipefail ensures codex exit code is preserved
          codex exec --full-auto "$INSTRUCTION" 2>&1 | tee /tmp/test-codex-create-pull-request.log
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_STEP_SUMMARY: ${{ env.GITHUB_STEP_SUMMARY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      - name: Print Agent output
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
        run: |
          echo "## Agent Output (JSONL)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````json' >> $GITHUB_STEP_SUMMARY
          if [ -f ${{ env.GITHUB_AW_SAFE_OUTPUTS }} ]; then
            cat ${{ env.GITHUB_AW_SAFE_OUTPUTS }} >> $GITHUB_STEP_SUMMARY
            # Ensure there's a newline after the file content if it doesn't end with one
            if [ -s ${{ env.GITHUB_AW_SAFE_OUTPUTS }} ] && [ "$(tail -c1 ${{ env.GITHUB_AW_SAFE_OUTPUTS }})" != "" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "No agent output file found" >> $GITHUB_STEP_SUMMARY
          fi
          echo '``````' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
      - name: Upload agentic output file
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: safe_output.jsonl
          path: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          if-no-files-found: warn
      - name: Ingest agent output
        id: collect_output
        uses: actions/github-script@v8
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_AW_SAFE_OUTPUTS_CONFIG: "{\"create-pull-request\":{}}"
        with:
          script: |
            async function main() {
              const fs = require("fs");
              /**
               * Sanitizes content for safe output in GitHub Actions
               * @param {string} content - The content to sanitize
               * @returns {string} The sanitized content
               */
              function sanitizeContent(content) {
                if (!content || typeof content !== "string") {
                  return "";
                }
                // Read allowed domains from environment variable
                const allowedDomainsEnv = process.env.GITHUB_AW_ALLOWED_DOMAINS;
                const defaultAllowedDomains = [
                  "github.com",
                  "github.io",
                  "githubusercontent.com",
                  "githubassets.com",
                  "github.dev",
                  "codespaces.new",
                ];
                const allowedDomains = allowedDomainsEnv
                  ? allowedDomainsEnv
                      .split(",")
                      .map(d => d.trim())
                      .filter(d => d)
                  : defaultAllowedDomains;
                let sanitized = content;
                // Neutralize @mentions to prevent unintended notifications
                sanitized = neutralizeMentions(sanitized);
                // Remove XML comments to prevent content hiding
                sanitized = removeXmlComments(sanitized);
                // Remove ANSI escape sequences BEFORE removing control characters
                sanitized = sanitized.replace(/\x1b\[[0-9;]*[mGKH]/g, "");
                // Remove control characters (except newlines and tabs)
                sanitized = sanitized.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, "");
                // URI filtering - replace non-https protocols with "(redacted)"
                sanitized = sanitizeUrlProtocols(sanitized);
                // Domain filtering for HTTPS URIs
                sanitized = sanitizeUrlDomains(sanitized);
                // Limit total length to prevent DoS (0.5MB max)
                const maxLength = 524288;
                if (sanitized.length > maxLength) {
                  sanitized =
                    sanitized.substring(0, maxLength) +
                    "\n[Content truncated due to length]";
                }
                // Limit number of lines to prevent log flooding (65k max)
                const lines = sanitized.split("\n");
                const maxLines = 65000;
                if (lines.length > maxLines) {
                  sanitized =
                    lines.slice(0, maxLines).join("\n") +
                    "\n[Content truncated due to line count]";
                }
                // ANSI escape sequences already removed earlier in the function
                // Neutralize common bot trigger phrases
                sanitized = neutralizeBotTriggers(sanitized);
                // Trim excessive whitespace
                return sanitized.trim();
                /**
                 * Remove unknown domains
                 * @param {string} s - The string to process
                 * @returns {string} The string with unknown domains redacted
                 */
                function sanitizeUrlDomains(s) {
                  return s.replace(/\bhttps:\/\/[^\s\])}'"<>&\x00-\x1f,;]+/gi, match => {
                    // Extract just the URL part after https://
                    const urlAfterProtocol = match.slice(8); // Remove 'https://'
                    // Extract the hostname part (before first slash, colon, or other delimiter)
                    const hostname = urlAfterProtocol.split(/[\/:\?#]/)[0].toLowerCase();
                    // Check if this domain or any parent domain is in the allowlist
                    const isAllowed = allowedDomains.some(allowedDomain => {
                      const normalizedAllowed = allowedDomain.toLowerCase();
                      return (
                        hostname === normalizedAllowed ||
                        hostname.endsWith("." + normalizedAllowed)
                      );
                    });
                    return isAllowed ? match : "(redacted)";
                  });
                }
                /**
                 * Remove unknown protocols except https
                 * @param {string} s - The string to process
                 * @returns {string} The string with non-https protocols redacted
                 */
                function sanitizeUrlProtocols(s) {
                  // Match protocol:// patterns (URLs) and standalone protocol: patterns that look like URLs
                  // Avoid matching command line flags like -v:10 or z3 -memory:high
                  return s.replace(
                    /\b(\w+):\/\/[^\s\])}'"<>&\x00-\x1f]+/gi,
                    (match, protocol) => {
                      // Allow https (case insensitive), redact everything else
                      return protocol.toLowerCase() === "https" ? match : "(redacted)";
                    }
                  );
                }
                /**
                 * Neutralizes @mentions by wrapping them in backticks
                 * @param {string} s - The string to process
                 * @returns {string} The string with neutralized mentions
                 */
                function neutralizeMentions(s) {
                  // Replace @name or @org/team outside code with `@name`
                  return s.replace(
                    /(^|[^\w`])@([A-Za-z0-9](?:[A-Za-z0-9-]{0,37}[A-Za-z0-9])?(?:\/[A-Za-z0-9._-]+)?)/g,
                    (_m, p1, p2) => `${p1}\`@${p2}\``
                  );
                }
                /**
                 * Removes XML comments to prevent content hiding
                 * @param {string} s - The string to process
                 * @returns {string} The string with XML comments removed
                 */
                function removeXmlComments(s) {
                  // Remove XML/HTML comments including malformed ones that might be used to hide content
                  // Matches: <!-- ... --> and <!--- ... --> and <!--- ... --!> variations
                  return s.replace(/<!--[\s\S]*?-->/g, "").replace(/<!--[\s\S]*?--!>/g, "");
                }
                /**
                 * Neutralizes bot trigger phrases by wrapping them in backticks
                 * @param {string} s - The string to process
                 * @returns {string} The string with neutralized bot triggers
                 */
                function neutralizeBotTriggers(s) {
                  // Neutralize common bot trigger phrases like "fixes #123", "closes #asdfs", etc.
                  return s.replace(
                    /\b(fixes?|closes?|resolves?|fix|close|resolve)\s+#(\w+)/gi,
                    (match, action, ref) => `\`${action} #${ref}\``
                  );
                }
              }
              /**
               * Gets the maximum allowed count for a given output type
               * @param {string} itemType - The output item type
               * @param {any} config - The safe-outputs configuration
               * @returns {number} The maximum allowed count
               */
              function getMaxAllowedForType(itemType, config) {
                // Check if max is explicitly specified in config
                if (
                  config &&
                  config[itemType] &&
                  typeof config[itemType] === "object" &&
                  config[itemType].max
                ) {
                  return config[itemType].max;
                }
                // Use default limits for plural-supported types
                switch (itemType) {
                  case "create-issue":
                    return 1; // Only one issue allowed
                  case "add-comment":
                    return 1; // Only one comment allowed
                  case "create-pull-request":
                    return 1; // Only one pull request allowed
                  case "create-pull-request-review-comment":
                    return 10; // Default to 10 review comments allowed
                  case "add-labels":
                    return 5; // Only one labels operation allowed
                  case "update-issue":
                    return 1; // Only one issue update allowed
                  case "push-to-pr-branch":
                    return 1; // Only one push to branch allowed
                  case "create-discussion":
                    return 1; // Only one discussion allowed
                  case "missing-tool":
                    return 1000; // Allow many missing tool reports (default: unlimited)
                  case "create-code-scanning-alert":
                    return 1000; // Allow many repository security advisories (default: unlimited)
                  default:
                    return 1; // Default to single item for unknown types
                }
              }
              /**
               * Attempts to repair common JSON syntax issues in LLM-generated content
               * @param {string} jsonStr - The potentially malformed JSON string
               * @returns {string} The repaired JSON string
               */
              function repairJson(jsonStr) {
                let repaired = jsonStr.trim();
                // remove invalid control characters like
                // U+0014 (DC4) — represented here as "\u0014"
                // Escape control characters not allowed in JSON strings (U+0000 through U+001F)
                // Preserve common JSON escapes for \b, \f, \n, \r, \t and use \uXXXX for the rest.
                /** @type {Record<number, string>} */
                const _ctrl = { 8: "\\b", 9: "\\t", 10: "\\n", 12: "\\f", 13: "\\r" };
                repaired = repaired.replace(/[\u0000-\u001F]/g, ch => {
                  const c = ch.charCodeAt(0);
                  return _ctrl[c] || "\\u" + c.toString(16).padStart(4, "0");
                });
                // Fix single quotes to double quotes (must be done first)
                repaired = repaired.replace(/'/g, '"');
                // Fix missing quotes around object keys
                repaired = repaired.replace(
                  /([{,]\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\s*:/g,
                  '$1"$2":'
                );
                // Fix newlines and tabs inside strings by escaping them
                repaired = repaired.replace(/"([^"\\]*)"/g, (match, content) => {
                  if (
                    content.includes("\n") ||
                    content.includes("\r") ||
                    content.includes("\t")
                  ) {
                    const escaped = content
                      .replace(/\\/g, "\\\\")
                      .replace(/\n/g, "\\n")
                      .replace(/\r/g, "\\r")
                      .replace(/\t/g, "\\t");
                    return `"${escaped}"`;
                  }
                  return match;
                });
                // Fix unescaped quotes inside string values
                repaired = repaired.replace(
                  /"([^"]*)"([^":,}\]]*)"([^"]*)"(\s*[,:}\]])/g,
                  (match, p1, p2, p3, p4) => `"${p1}\\"${p2}\\"${p3}"${p4}`
                );
                // Fix wrong bracket/brace types - arrays should end with ] not }
                repaired = repaired.replace(
                  /(\[\s*(?:"[^"]*"(?:\s*,\s*"[^"]*")*\s*),?)\s*}/g,
                  "$1]"
                );
                // Fix missing closing braces/brackets
                const openBraces = (repaired.match(/\{/g) || []).length;
                const closeBraces = (repaired.match(/\}/g) || []).length;
                if (openBraces > closeBraces) {
                  repaired += "}".repeat(openBraces - closeBraces);
                } else if (closeBraces > openBraces) {
                  repaired = "{".repeat(closeBraces - openBraces) + repaired;
                }
                // Fix missing closing brackets for arrays
                const openBrackets = (repaired.match(/\[/g) || []).length;
                const closeBrackets = (repaired.match(/\]/g) || []).length;
                if (openBrackets > closeBrackets) {
                  repaired += "]".repeat(openBrackets - closeBrackets);
                } else if (closeBrackets > openBrackets) {
                  repaired = "[".repeat(closeBrackets - openBrackets) + repaired;
                }
                // Fix trailing commas in objects and arrays (AFTER fixing brackets/braces)
                repaired = repaired.replace(/,(\s*[}\]])/g, "$1");
                return repaired;
              }
              /**
               * Validates that a value is a positive integer
               * @param {any} value - The value to validate
               * @param {string} fieldName - The name of the field being validated
               * @param {number} lineNum - The line number for error reporting
               * @returns {{isValid: boolean, error?: string, normalizedValue?: number}} Validation result
               */
              function validatePositiveInteger(value, fieldName, lineNum) {
                if (value === undefined || value === null) {
                  // Match the original error format for create-code-scanning-alert
                  if (fieldName.includes("create-code-scanning-alert 'line'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-code-scanning-alert requires a 'line' field (number or string)`,
                    };
                  }
                  if (fieldName.includes("create-pull-request-review-comment 'line'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-pull-request-review-comment requires a 'line' number`,
                    };
                  }
                  return {
                    isValid: false,
                    error: `Line ${lineNum}: ${fieldName} is required`,
                  };
                }
                if (typeof value !== "number" && typeof value !== "string") {
                  // Match the original error format for create-code-scanning-alert
                  if (fieldName.includes("create-code-scanning-alert 'line'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-code-scanning-alert requires a 'line' field (number or string)`,
                    };
                  }
                  if (fieldName.includes("create-pull-request-review-comment 'line'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-pull-request-review-comment requires a 'line' number or string field`,
                    };
                  }
                  return {
                    isValid: false,
                    error: `Line ${lineNum}: ${fieldName} must be a number or string`,
                  };
                }
                const parsed = typeof value === "string" ? parseInt(value, 10) : value;
                if (isNaN(parsed) || parsed <= 0 || !Number.isInteger(parsed)) {
                  // Match the original error format for different field types
                  if (fieldName.includes("create-code-scanning-alert 'line'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-code-scanning-alert 'line' must be a valid positive integer (got: ${value})`,
                    };
                  }
                  if (fieldName.includes("create-pull-request-review-comment 'line'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-pull-request-review-comment 'line' must be a positive integer`,
                    };
                  }
                  return {
                    isValid: false,
                    error: `Line ${lineNum}: ${fieldName} must be a positive integer (got: ${value})`,
                  };
                }
                return { isValid: true, normalizedValue: parsed };
              }
              /**
               * Validates an optional positive integer field
               * @param {any} value - The value to validate
               * @param {string} fieldName - The name of the field being validated
               * @param {number} lineNum - The line number for error reporting
               * @returns {{isValid: boolean, error?: string, normalizedValue?: number}} Validation result
               */
              function validateOptionalPositiveInteger(value, fieldName, lineNum) {
                if (value === undefined) {
                  return { isValid: true };
                }
                if (typeof value !== "number" && typeof value !== "string") {
                  // Match the original error format for specific field types
                  if (
                    fieldName.includes("create-pull-request-review-comment 'start_line'")
                  ) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-pull-request-review-comment 'start_line' must be a number or string`,
                    };
                  }
                  if (fieldName.includes("create-code-scanning-alert 'column'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-code-scanning-alert 'column' must be a number or string`,
                    };
                  }
                  return {
                    isValid: false,
                    error: `Line ${lineNum}: ${fieldName} must be a number or string`,
                  };
                }
                const parsed = typeof value === "string" ? parseInt(value, 10) : value;
                if (isNaN(parsed) || parsed <= 0 || !Number.isInteger(parsed)) {
                  // Match the original error format for different field types
                  if (
                    fieldName.includes("create-pull-request-review-comment 'start_line'")
                  ) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-pull-request-review-comment 'start_line' must be a positive integer`,
                    };
                  }
                  if (fieldName.includes("create-code-scanning-alert 'column'")) {
                    return {
                      isValid: false,
                      error: `Line ${lineNum}: create-code-scanning-alert 'column' must be a valid positive integer (got: ${value})`,
                    };
                  }
                  return {
                    isValid: false,
                    error: `Line ${lineNum}: ${fieldName} must be a positive integer (got: ${value})`,
                  };
                }
                return { isValid: true, normalizedValue: parsed };
              }
              /**
               * Validates an issue or pull request number (optional field)
               * @param {any} value - The value to validate
               * @param {string} fieldName - The name of the field being validated
               * @param {number} lineNum - The line number for error reporting
               * @returns {{isValid: boolean, error?: string}} Validation result
               */
              function validateIssueOrPRNumber(value, fieldName, lineNum) {
                if (value === undefined) {
                  return { isValid: true };
                }
                if (typeof value !== "number" && typeof value !== "string") {
                  return {
                    isValid: false,
                    error: `Line ${lineNum}: ${fieldName} must be a number or string`,
                  };
                }
                return { isValid: true };
              }
              /**
               * Attempts to parse JSON with repair fallback
               * @param {string} jsonStr - The JSON string to parse
               * @returns {Object|undefined} The parsed JSON object, or undefined if parsing fails
               */
              function parseJsonWithRepair(jsonStr) {
                try {
                  // First, try normal JSON.parse
                  return JSON.parse(jsonStr);
                } catch (originalError) {
                  try {
                    // If that fails, try repairing and parsing again
                    const repairedJson = repairJson(jsonStr);
                    return JSON.parse(repairedJson);
                  } catch (repairError) {
                    // If repair also fails, throw the error
                    core.info(`invalid input json: ${jsonStr}`);
                    const originalMsg =
                      originalError instanceof Error
                        ? originalError.message
                        : String(originalError);
                    const repairMsg =
                      repairError instanceof Error
                        ? repairError.message
                        : String(repairError);
                    throw new Error(
                      `JSON parsing failed. Original: ${originalMsg}. After attempted repair: ${repairMsg}`
                    );
                  }
                }
              }
              const outputFile = process.env.GITHUB_AW_SAFE_OUTPUTS;
              const safeOutputsConfig = process.env.GITHUB_AW_SAFE_OUTPUTS_CONFIG;
              if (!outputFile) {
                core.info("GITHUB_AW_SAFE_OUTPUTS not set, no output to collect");
                core.setOutput("output", "");
                return;
              }
              if (!fs.existsSync(outputFile)) {
                core.info(`Output file does not exist: ${outputFile}`);
                core.setOutput("output", "");
                return;
              }
              const outputContent = fs.readFileSync(outputFile, "utf8");
              if (outputContent.trim() === "") {
                core.info("Output file is empty");
                core.setOutput("output", "");
                return;
              }
              core.info(`Raw output content length: ${outputContent.length}`);
              // Parse the safe-outputs configuration
              /** @type {any} */
              let expectedOutputTypes = {};
              if (safeOutputsConfig) {
                try {
                  expectedOutputTypes = JSON.parse(safeOutputsConfig);
                  core.info(
                    `Expected output types: ${JSON.stringify(Object.keys(expectedOutputTypes))}`
                  );
                } catch (error) {
                  const errorMsg = error instanceof Error ? error.message : String(error);
                  core.info(`Warning: Could not parse safe-outputs config: ${errorMsg}`);
                }
              }
              // Parse JSONL content
              const lines = outputContent.trim().split("\n");
              const parsedItems = [];
              const errors = [];
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === "") continue; // Skip empty lines
                try {
                  /** @type {any} */
                  const item = parseJsonWithRepair(line);
                  // If item is undefined (failed to parse), add error and process next line
                  if (item === undefined) {
                    errors.push(`Line ${i + 1}: Invalid JSON - JSON parsing failed`);
                    continue;
                  }
                  // Validate that the item has a 'type' field
                  if (!item.type) {
                    errors.push(`Line ${i + 1}: Missing required 'type' field`);
                    continue;
                  }
                  // Validate against expected output types
                  const itemType = item.type;
                  if (!expectedOutputTypes[itemType]) {
                    errors.push(
                      `Line ${i + 1}: Unexpected output type '${itemType}'. Expected one of: ${Object.keys(expectedOutputTypes).join(", ")}`
                    );
                    continue;
                  }
                  // Check for too many items of the same type
                  const typeCount = parsedItems.filter(
                    existing => existing.type === itemType
                  ).length;
                  const maxAllowed = getMaxAllowedForType(itemType, expectedOutputTypes);
                  if (typeCount >= maxAllowed) {
                    errors.push(
                      `Line ${i + 1}: Too many items of type '${itemType}'. Maximum allowed: ${maxAllowed}.`
                    );
                    continue;
                  }
                  // Basic validation based on type
                  switch (itemType) {
                    case "create-issue":
                      if (!item.title || typeof item.title !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-issue requires a 'title' string field`
                        );
                        continue;
                      }
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-issue requires a 'body' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.title = sanitizeContent(item.title);
                      item.body = sanitizeContent(item.body);
                      // Sanitize labels if present
                      if (item.labels && Array.isArray(item.labels)) {
                        item.labels = item.labels.map(
                          /** @param {any} label */ label =>
                            typeof label === "string" ? sanitizeContent(label) : label
                        );
                      }
                      break;
                    case "add-comment":
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: add-comment requires a 'body' string field`
                        );
                        continue;
                      }
                      // Validate optional issue_number field
                      const issueNumValidation = validateIssueOrPRNumber(
                        item.issue_number,
                        "add-comment 'issue_number'",
                        i + 1
                      );
                      if (!issueNumValidation.isValid) {
                        errors.push(issueNumValidation.error);
                        continue;
                      }
                      // Sanitize text content
                      item.body = sanitizeContent(item.body);
                      break;
                    case "create-pull-request":
                      if (!item.title || typeof item.title !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-pull-request requires a 'title' string field`
                        );
                        continue;
                      }
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-pull-request requires a 'body' string field`
                        );
                        continue;
                      }
                      if (!item.branch || typeof item.branch !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-pull-request requires a 'branch' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.title = sanitizeContent(item.title);
                      item.body = sanitizeContent(item.body);
                      item.branch = sanitizeContent(item.branch);
                      // Sanitize labels if present
                      if (item.labels && Array.isArray(item.labels)) {
                        item.labels = item.labels.map(
                          /** @param {any} label */ label =>
                            typeof label === "string" ? sanitizeContent(label) : label
                        );
                      }
                      break;
                    case "add-labels":
                      if (!item.labels || !Array.isArray(item.labels)) {
                        errors.push(
                          `Line ${i + 1}: add-labels requires a 'labels' array field`
                        );
                        continue;
                      }
                      if (
                        item.labels.some(
                          /** @param {any} label */ label => typeof label !== "string"
                        )
                      ) {
                        errors.push(
                          `Line ${i + 1}: add-labels labels array must contain only strings`
                        );
                        continue;
                      }
                      // Validate optional issue_number field
                      const labelsIssueNumValidation = validateIssueOrPRNumber(
                        item.issue_number,
                        "add-labels 'issue_number'",
                        i + 1
                      );
                      if (!labelsIssueNumValidation.isValid) {
                        errors.push(labelsIssueNumValidation.error);
                        continue;
                      }
                      // Sanitize label strings
                      item.labels = item.labels.map(
                        /** @param {any} label */ label => sanitizeContent(label)
                      );
                      break;
                    case "update-issue":
                      // Check that at least one updateable field is provided
                      const hasValidField =
                        item.status !== undefined ||
                        item.title !== undefined ||
                        item.body !== undefined;
                      if (!hasValidField) {
                        errors.push(
                          `Line ${i + 1}: update-issue requires at least one of: 'status', 'title', or 'body' fields`
                        );
                        continue;
                      }
                      // Validate status if provided
                      if (item.status !== undefined) {
                        if (
                          typeof item.status !== "string" ||
                          (item.status !== "open" && item.status !== "closed")
                        ) {
                          errors.push(
                            `Line ${i + 1}: update-issue 'status' must be 'open' or 'closed'`
                          );
                          continue;
                        }
                      }
                      // Validate title if provided
                      if (item.title !== undefined) {
                        if (typeof item.title !== "string") {
                          errors.push(
                            `Line ${i + 1}: update-issue 'title' must be a string`
                          );
                          continue;
                        }
                        item.title = sanitizeContent(item.title);
                      }
                      // Validate body if provided
                      if (item.body !== undefined) {
                        if (typeof item.body !== "string") {
                          errors.push(
                            `Line ${i + 1}: update-issue 'body' must be a string`
                          );
                          continue;
                        }
                        item.body = sanitizeContent(item.body);
                      }
                      // Validate issue_number if provided (for target "*")
                      const updateIssueNumValidation = validateIssueOrPRNumber(
                        item.issue_number,
                        "update-issue 'issue_number'",
                        i + 1
                      );
                      if (!updateIssueNumValidation.isValid) {
                        errors.push(updateIssueNumValidation.error);
                        continue;
                      }
                      break;
                    case "push-to-pr-branch":
                      // Validate required branch field
                      if (!item.branch || typeof item.branch !== "string") {
                        errors.push(
                          `Line ${i + 1}: push-to-pr-branch requires a 'branch' string field`
                        );
                        continue;
                      }
                      // Validate required message field
                      if (!item.message || typeof item.message !== "string") {
                        errors.push(
                          `Line ${i + 1}: push-to-pr-branch requires a 'message' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.branch = sanitizeContent(item.branch);
                      item.message = sanitizeContent(item.message);
                      // Validate pull_request_number if provided (for target "*")
                      const pushPRNumValidation = validateIssueOrPRNumber(
                        item.pull_request_number,
                        "push-to-pr-branch 'pull_request_number'",
                        i + 1
                      );
                      if (!pushPRNumValidation.isValid) {
                        errors.push(pushPRNumValidation.error);
                        continue;
                      }
                      break;
                    case "create-pull-request-review-comment":
                      // Validate required path field
                      if (!item.path || typeof item.path !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-pull-request-review-comment requires a 'path' string field`
                        );
                        continue;
                      }
                      // Validate required line field
                      const lineValidation = validatePositiveInteger(
                        item.line,
                        "create-pull-request-review-comment 'line'",
                        i + 1
                      );
                      if (!lineValidation.isValid) {
                        errors.push(lineValidation.error);
                        continue;
                      }
                      // lineValidation.normalizedValue is guaranteed to be defined when isValid is true
                      const lineNumber = lineValidation.normalizedValue;
                      // Validate required body field
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-pull-request-review-comment requires a 'body' string field`
                        );
                        continue;
                      }
                      // Sanitize required text content
                      item.body = sanitizeContent(item.body);
                      // Validate optional start_line field
                      const startLineValidation = validateOptionalPositiveInteger(
                        item.start_line,
                        "create-pull-request-review-comment 'start_line'",
                        i + 1
                      );
                      if (!startLineValidation.isValid) {
                        errors.push(startLineValidation.error);
                        continue;
                      }
                      if (
                        startLineValidation.normalizedValue !== undefined &&
                        lineNumber !== undefined &&
                        startLineValidation.normalizedValue > lineNumber
                      ) {
                        errors.push(
                          `Line ${i + 1}: create-pull-request-review-comment 'start_line' must be less than or equal to 'line'`
                        );
                        continue;
                      }
                      // Validate optional side field
                      if (item.side !== undefined) {
                        if (
                          typeof item.side !== "string" ||
                          (item.side !== "LEFT" && item.side !== "RIGHT")
                        ) {
                          errors.push(
                            `Line ${i + 1}: create-pull-request-review-comment 'side' must be 'LEFT' or 'RIGHT'`
                          );
                          continue;
                        }
                      }
                      break;
                    case "create-discussion":
                      if (!item.title || typeof item.title !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-discussion requires a 'title' string field`
                        );
                        continue;
                      }
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-discussion requires a 'body' string field`
                        );
                        continue;
                      }
                      // Validate optional category field
                      if (item.category !== undefined) {
                        if (typeof item.category !== "string") {
                          errors.push(
                            `Line ${i + 1}: create-discussion 'category' must be a string`
                          );
                          continue;
                        }
                        item.category = sanitizeContent(item.category);
                      }
                      // Sanitize text content
                      item.title = sanitizeContent(item.title);
                      item.body = sanitizeContent(item.body);
                      break;
                    case "missing-tool":
                      // Validate required tool field
                      if (!item.tool || typeof item.tool !== "string") {
                        errors.push(
                          `Line ${i + 1}: missing-tool requires a 'tool' string field`
                        );
                        continue;
                      }
                      // Validate required reason field
                      if (!item.reason || typeof item.reason !== "string") {
                        errors.push(
                          `Line ${i + 1}: missing-tool requires a 'reason' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.tool = sanitizeContent(item.tool);
                      item.reason = sanitizeContent(item.reason);
                      // Validate optional alternatives field
                      if (item.alternatives !== undefined) {
                        if (typeof item.alternatives !== "string") {
                          errors.push(
                            `Line ${i + 1}: missing-tool 'alternatives' must be a string`
                          );
                          continue;
                        }
                        item.alternatives = sanitizeContent(item.alternatives);
                      }
                      break;
                    case "create-code-scanning-alert":
                      // Validate required fields
                      if (!item.file || typeof item.file !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert requires a 'file' field (string)`
                        );
                        continue;
                      }
                      const alertLineValidation = validatePositiveInteger(
                        item.line,
                        "create-code-scanning-alert 'line'",
                        i + 1
                      );
                      if (!alertLineValidation.isValid) {
                        errors.push(alertLineValidation.error);
                        continue;
                      }
                      if (!item.severity || typeof item.severity !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert requires a 'severity' field (string)`
                        );
                        continue;
                      }
                      if (!item.message || typeof item.message !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert requires a 'message' field (string)`
                        );
                        continue;
                      }
                      // Validate severity level
                      const allowedSeverities = ["error", "warning", "info", "note"];
                      if (!allowedSeverities.includes(item.severity.toLowerCase())) {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert 'severity' must be one of: ${allowedSeverities.join(", ")}`
                        );
                        continue;
                      }
                      // Validate optional column field
                      const columnValidation = validateOptionalPositiveInteger(
                        item.column,
                        "create-code-scanning-alert 'column'",
                        i + 1
                      );
                      if (!columnValidation.isValid) {
                        errors.push(columnValidation.error);
                        continue;
                      }
                      // Validate optional ruleIdSuffix field
                      if (item.ruleIdSuffix !== undefined) {
                        if (typeof item.ruleIdSuffix !== "string") {
                          errors.push(
                            `Line ${i + 1}: create-code-scanning-alert 'ruleIdSuffix' must be a string`
                          );
                          continue;
                        }
                        if (!/^[a-zA-Z0-9_-]+$/.test(item.ruleIdSuffix.trim())) {
                          errors.push(
                            `Line ${i + 1}: create-code-scanning-alert 'ruleIdSuffix' must contain only alphanumeric characters, hyphens, and underscores`
                          );
                          continue;
                        }
                      }
                      // Normalize severity to lowercase and sanitize string fields
                      item.severity = item.severity.toLowerCase();
                      item.file = sanitizeContent(item.file);
                      item.severity = sanitizeContent(item.severity);
                      item.message = sanitizeContent(item.message);
                      if (item.ruleIdSuffix) {
                        item.ruleIdSuffix = sanitizeContent(item.ruleIdSuffix);
                      }
                      break;
                    default:
                      errors.push(`Line ${i + 1}: Unknown output type '${itemType}'`);
                      continue;
                  }
                  core.info(`Line ${i + 1}: Valid ${itemType} item`);
                  parsedItems.push(item);
                } catch (error) {
                  const errorMsg = error instanceof Error ? error.message : String(error);
                  errors.push(`Line ${i + 1}: Invalid JSON - ${errorMsg}`);
                }
              }
              // Report validation results
              if (errors.length > 0) {
                core.warning("Validation errors found:");
                errors.forEach(error => core.warning(`  - ${error}`));
                if (parsedItems.length === 0) {
                  core.setFailed(errors.map(e => `  - ${e}`).join("\n"));
                  return;
                }
                // For now, we'll continue with valid items but log the errors
                // In the future, we might want to fail the workflow for invalid items
              }
              core.info(`Successfully parsed ${parsedItems.length} valid output items`);
              // Set the parsed and validated items as output
              const validatedOutput = {
                items: parsedItems,
                errors: errors,
              };
              // Store validatedOutput JSON in "agent_output.json" file
              const agentOutputFile = "/tmp/agent_output.json";
              const validatedOutputJson = JSON.stringify(validatedOutput);
              try {
                // Ensure the /tmp directory exists
                fs.mkdirSync("/tmp", { recursive: true });
                fs.writeFileSync(agentOutputFile, validatedOutputJson, "utf8");
                core.info(`Stored validated output to: ${agentOutputFile}`);
                // Set the environment variable GITHUB_AW_AGENT_OUTPUT to the file path
                core.exportVariable("GITHUB_AW_AGENT_OUTPUT", agentOutputFile);
              } catch (error) {
                const errorMsg = error instanceof Error ? error.message : String(error);
                core.error(`Failed to write agent output file: ${errorMsg}`);
              }
              core.setOutput("output", JSON.stringify(validatedOutput));
              core.setOutput("raw_output", outputContent);
              // Write processed output to step summary using core.summary
              try {
                await core.summary
                  .addRaw("## Processed Output\n\n")
                  .addRaw("```json\n")
                  .addRaw(JSON.stringify(validatedOutput))
                  .addRaw("\n```\n")
                  .write();
                core.info("Successfully wrote processed output to step summary");
              } catch (error) {
                const errorMsg = error instanceof Error ? error.message : String(error);
                core.warning(`Failed to write to step summary: ${errorMsg}`);
              }
            }
            // Call the main function
            await main();
      - name: Upload sanitized agent output
        if: always() && env.GITHUB_AW_AGENT_OUTPUT
        uses: actions/upload-artifact@v4
        with:
          name: agent_output.json
          path: ${{ env.GITHUB_AW_AGENT_OUTPUT }}
          if-no-files-found: warn
      - name: Parse agent logs for step summary
        if: always()
        uses: actions/github-script@v8
        env:
          GITHUB_AW_AGENT_OUTPUT: /tmp/test-codex-create-pull-request.log
        with:
          script: |
            function main() {
              const fs = require("fs");
              try {
                const logFile = process.env.GITHUB_AW_AGENT_OUTPUT;
                if (!logFile) {
                  core.info("No agent log file specified");
                  return;
                }
                if (!fs.existsSync(logFile)) {
                  core.info(`Log file not found: ${logFile}`);
                  return;
                }
                const content = fs.readFileSync(logFile, "utf8");
                const parsedLog = parseCodexLog(content);
                if (parsedLog) {
                  core.summary.addRaw(parsedLog).write();
                  core.info("Codex log parsed successfully");
                } else {
                  core.error("Failed to parse Codex log");
                }
              } catch (error) {
                core.setFailed(error instanceof Error ? error : String(error));
              }
            }
            /**
             * Parse codex log content and format as markdown
             * @param {string} logContent - The raw log content to parse
             * @returns {string} Formatted markdown content
             */
            function parseCodexLog(logContent) {
              try {
                const lines = logContent.split("\n");
                let markdown = "## 🤖 Commands and Tools\n\n";
                const commandSummary = [];
                // First pass: collect commands for summary
                for (let i = 0; i < lines.length; i++) {
                  const line = lines[i];
                  // Detect tool usage and exec commands
                  if (line.includes("] tool ") && line.includes("(")) {
                    // Extract tool name
                    const toolMatch = line.match(/\] tool ([^(]+)\(/);
                    if (toolMatch) {
                      const toolName = toolMatch[1];
                      // Look ahead to find the result status
                      let statusIcon = "❓"; // Unknown by default
                      for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
                        const nextLine = lines[j];
                        if (nextLine.includes("success in")) {
                          statusIcon = "✅";
                          break;
                        } else if (
                          nextLine.includes("failure in") ||
                          nextLine.includes("error in") ||
                          nextLine.includes("failed in")
                        ) {
                          statusIcon = "❌";
                          break;
                        }
                      }
                      if (toolName.includes(".")) {
                        // Format as provider::method
                        const parts = toolName.split(".");
                        const provider = parts[0];
                        const method = parts.slice(1).join("_");
                        commandSummary.push(
                          `* ${statusIcon} \`${provider}::${method}(...)\``
                        );
                      } else {
                        commandSummary.push(`* ${statusIcon} \`${toolName}(...)\``);
                      }
                    }
                  } else if (line.includes("] exec ")) {
                    // Extract exec command
                    const execMatch = line.match(/exec (.+?) in/);
                    if (execMatch) {
                      const formattedCommand = formatBashCommand(execMatch[1]);
                      // Look ahead to find the result status
                      let statusIcon = "❓"; // Unknown by default
                      for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
                        const nextLine = lines[j];
                        if (nextLine.includes("succeeded in")) {
                          statusIcon = "✅";
                          break;
                        } else if (
                          nextLine.includes("failed in") ||
                          nextLine.includes("error")
                        ) {
                          statusIcon = "❌";
                          break;
                        }
                      }
                      commandSummary.push(`* ${statusIcon} \`${formattedCommand}\``);
                    }
                  }
                }
                // Add command summary
                if (commandSummary.length > 0) {
                  for (const cmd of commandSummary) {
                    markdown += `${cmd}\n`;
                  }
                } else {
                  markdown += "No commands or tools used.\n";
                }
                // Add Information section
                markdown += "\n## 📊 Information\n\n";
                // Extract metadata from Codex logs
                let totalTokens = 0;
                const tokenMatches = logContent.match(/tokens used: (\d+)/g);
                if (tokenMatches) {
                  for (const match of tokenMatches) {
                    const numberMatch = match.match(/(\d+)/);
                    if (numberMatch) {
                      const tokens = parseInt(numberMatch[1]);
                      totalTokens += tokens;
                    }
                  }
                }
                if (totalTokens > 0) {
                  markdown += `**Total Tokens Used:** ${totalTokens.toLocaleString()}\n\n`;
                }
                // Count tool calls and exec commands
                const toolCalls = (logContent.match(/\] tool /g) || []).length;
                const execCommands = (logContent.match(/\] exec /g) || []).length;
                if (toolCalls > 0) {
                  markdown += `**Tool Calls:** ${toolCalls}\n\n`;
                }
                if (execCommands > 0) {
                  markdown += `**Commands Executed:** ${execCommands}\n\n`;
                }
                markdown += "\n## 🤖 Reasoning\n\n";
                // Second pass: process full conversation flow with interleaved reasoning, tools, and commands
                let inThinkingSection = false;
                for (let i = 0; i < lines.length; i++) {
                  const line = lines[i];
                  // Skip metadata lines
                  if (
                    line.includes("OpenAI Codex") ||
                    line.startsWith("--------") ||
                    line.includes("workdir:") ||
                    line.includes("model:") ||
                    line.includes("provider:") ||
                    line.includes("approval:") ||
                    line.includes("sandbox:") ||
                    line.includes("reasoning effort:") ||
                    line.includes("reasoning summaries:") ||
                    line.includes("tokens used:")
                  ) {
                    continue;
                  }
                  // Process thinking sections
                  if (line.includes("] thinking")) {
                    inThinkingSection = true;
                    continue;
                  }
                  // Process tool calls
                  if (line.includes("] tool ") && line.includes("(")) {
                    inThinkingSection = false;
                    const toolMatch = line.match(/\] tool ([^(]+)\(/);
                    if (toolMatch) {
                      const toolName = toolMatch[1];
                      // Look ahead to find the result status
                      let statusIcon = "❓"; // Unknown by default
                      for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
                        const nextLine = lines[j];
                        if (nextLine.includes("success in")) {
                          statusIcon = "✅";
                          break;
                        } else if (
                          nextLine.includes("failure in") ||
                          nextLine.includes("error in") ||
                          nextLine.includes("failed in")
                        ) {
                          statusIcon = "❌";
                          break;
                        }
                      }
                      if (toolName.includes(".")) {
                        const parts = toolName.split(".");
                        const provider = parts[0];
                        const method = parts.slice(1).join("_");
                        markdown += `${statusIcon} ${provider}::${method}(...)\n\n`;
                      } else {
                        markdown += `${statusIcon} ${toolName}(...)\n\n`;
                      }
                    }
                    continue;
                  }
                  // Process exec commands
                  if (line.includes("] exec ")) {
                    inThinkingSection = false;
                    const execMatch = line.match(/exec (.+?) in/);
                    if (execMatch) {
                      const formattedCommand = formatBashCommand(execMatch[1]);
                      // Look ahead to find the result status
                      let statusIcon = "❓"; // Unknown by default
                      for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
                        const nextLine = lines[j];
                        if (nextLine.includes("succeeded in")) {
                          statusIcon = "✅";
                          break;
                        } else if (
                          nextLine.includes("failed in") ||
                          nextLine.includes("error")
                        ) {
                          statusIcon = "❌";
                          break;
                        }
                      }
                      markdown += `${statusIcon} \`${formattedCommand}\`\n\n`;
                    }
                    continue;
                  }
                  // Process thinking content
                  if (
                    inThinkingSection &&
                    line.trim().length > 20 &&
                    !line.startsWith("[2025-")
                  ) {
                    const trimmed = line.trim();
                    // Add thinking content directly
                    markdown += `${trimmed}\n\n`;
                  }
                }
                return markdown;
              } catch (error) {
                core.error(`Error parsing Codex log: ${error}`);
                return "## 🤖 Commands and Tools\n\nError parsing log content.\n\n## 🤖 Reasoning\n\nUnable to parse reasoning from log.\n\n";
              }
            }
            /**
             * Format bash command for display
             * @param {string} command - The command to format
             * @returns {string} Formatted command string
             */
            function formatBashCommand(command) {
              if (!command) return "";
              // Convert multi-line commands to single line by replacing newlines with spaces
              // and collapsing multiple spaces
              let formatted = command
                .replace(/\n/g, " ") // Replace newlines with spaces
                .replace(/\r/g, " ") // Replace carriage returns with spaces
                .replace(/\t/g, " ") // Replace tabs with spaces
                .replace(/\s+/g, " ") // Collapse multiple spaces into one
                .trim(); // Remove leading/trailing whitespace
              // Escape backticks to prevent markdown issues
              formatted = formatted.replace(/`/g, "\\`");
              // Truncate if too long (keep reasonable length for summary)
              const maxLength = 80;
              if (formatted.length > maxLength) {
                formatted = formatted.substring(0, maxLength) + "...";
              }
              return formatted;
            }
            /**
             * Truncate string to maximum length
             * @param {string} str - The string to truncate
             * @param {number} maxLength - Maximum length allowed
             * @returns {string} Truncated string
             */
            function truncateString(str, maxLength) {
              if (!str) return "";
              if (str.length <= maxLength) return str;
              return str.substring(0, maxLength) + "...";
            }
            // Export for testing
            if (typeof module !== "undefined" && module.exports) {
              module.exports = { parseCodexLog, formatBashCommand, truncateString };
            }
            main();
      - name: Upload agent logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-codex-create-pull-request.log
          path: /tmp/test-codex-create-pull-request.log
          if-no-files-found: warn
      - name: Validate agent logs for errors
        if: always()
        uses: actions/github-script@v8
        env:
          GITHUB_AW_AGENT_OUTPUT: /tmp/test-codex-create-pull-request.log
          GITHUB_AW_ERROR_PATTERNS: "[{\"pattern\":\"\\\\[(\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2})\\\\]\\\\s+stream\\\\s+(error):\\\\s+(.+)\",\"level_group\":2,\"message_group\":3,\"description\":\"Codex stream errors with timestamp\"},{\"pattern\":\"\\\\[(\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2})\\\\]\\\\s+(ERROR):\\\\s+(.+)\",\"level_group\":2,\"message_group\":3,\"description\":\"Codex ERROR messages with timestamp\"},{\"pattern\":\"\\\\[(\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2})\\\\]\\\\s+(WARN|WARNING):\\\\s+(.+)\",\"level_group\":2,\"message_group\":3,\"description\":\"Codex warning messages with timestamp\"}]"
        with:
          script: |
            function main() {
              const fs = require("fs");
              try {
                const logFile = process.env.GITHUB_AW_AGENT_OUTPUT;
                if (!logFile) {
                  throw new Error(
                    "GITHUB_AW_AGENT_OUTPUT environment variable is required"
                  );
                }
                if (!fs.existsSync(logFile)) {
                  throw new Error(`Log file not found: ${logFile}`);
                }
                // Get error patterns from environment variables
                const patterns = getErrorPatternsFromEnv();
                if (patterns.length === 0) {
                  throw new Error(
                    "GITHUB_AW_ERROR_PATTERNS environment variable is required and must contain at least one pattern"
                  );
                }
                const content = fs.readFileSync(logFile, "utf8");
                const hasErrors = validateErrors(content, patterns);
                if (hasErrors) {
                  core.setFailed("Errors detected in agent logs - failing workflow step");
                } else {
                  core.info("Error validation completed successfully");
                }
              } catch (error) {
                console.debug(error);
                core.setFailed(
                  `Error validating log: ${error instanceof Error ? error.message : String(error)}`
                );
              }
            }
            function getErrorPatternsFromEnv() {
              const patternsEnv = process.env.GITHUB_AW_ERROR_PATTERNS;
              if (!patternsEnv) {
                throw new Error(
                  "GITHUB_AW_ERROR_PATTERNS environment variable is required"
                );
              }
              try {
                const patterns = JSON.parse(patternsEnv);
                if (!Array.isArray(patterns)) {
                  throw new Error("GITHUB_AW_ERROR_PATTERNS must be a JSON array");
                }
                return patterns;
              } catch (e) {
                throw new Error(
                  `Failed to parse GITHUB_AW_ERROR_PATTERNS as JSON: ${e instanceof Error ? e.message : String(e)}`
                );
              }
            }
            /**
             * @param {string} logContent
             * @param {any[]} patterns
             * @returns {boolean}
             */
            function validateErrors(logContent, patterns) {
              const lines = logContent.split("\n");
              let hasErrors = false;
              for (const pattern of patterns) {
                const regex = new RegExp(pattern.pattern, "g");
                for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                  const line = lines[lineIndex];
                  let match;
                  while ((match = regex.exec(line)) !== null) {
                    const level = extractLevel(match, pattern);
                    const message = extractMessage(match, pattern, line);
                    const errorMessage = `Line ${lineIndex + 1}: ${message} (Pattern: ${pattern.description || "Unknown pattern"}, Raw log: ${truncateString(line.trim(), 120)})`;
                    if (level.toLowerCase() === "error") {
                      core.error(errorMessage);
                      hasErrors = true;
                    } else {
                      core.warning(errorMessage);
                    }
                  }
                }
              }
              return hasErrors;
            }
            /**
             * @param {any} match
             * @param {any} pattern
             * @returns {string}
             */
            function extractLevel(match, pattern) {
              if (
                pattern.level_group &&
                pattern.level_group > 0 &&
                match[pattern.level_group]
              ) {
                return match[pattern.level_group];
              }
              // Try to infer level from the match content
              const fullMatch = match[0];
              if (fullMatch.toLowerCase().includes("error")) {
                return "error";
              } else if (fullMatch.toLowerCase().includes("warn")) {
                return "warning";
              }
              return "unknown";
            }
            /**
             * @param {any} match
             * @param {any} pattern
             * @param {any} fullLine
             * @returns {string}
             */
            function extractMessage(match, pattern, fullLine) {
              if (
                pattern.message_group &&
                pattern.message_group > 0 &&
                match[pattern.message_group]
              ) {
                return match[pattern.message_group].trim();
              }
              // Fallback to the full match or line
              return match[0] || fullLine.trim();
            }
            /**
             * @param {any} str
             * @param {any} maxLength
             * @returns {string}
             */
            function truncateString(str, maxLength) {
              if (!str) return "";
              if (str.length <= maxLength) return str;
              return str.substring(0, maxLength) + "...";
            }
            // Export for testing
            if (typeof module !== "undefined" && module.exports) {
              module.exports = {
                validateErrors,
                extractLevel,
                extractMessage,
                getErrorPatternsFromEnv,
                truncateString,
              };
            }
            // Only run main if this script is executed directly, not when imported for testing
            if (typeof module === "undefined" || require.main === module) {
              main();
            }
      - name: Generate git patch
        if: always()
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          # Check current git status
          echo "Current git status:"
          git status
          
          # Extract branch name from JSONL output
          BRANCH_NAME=""
          if [ -f "$GITHUB_AW_SAFE_OUTPUTS" ]; then
            echo "Checking for branch name in JSONL output..."
            while IFS= read -r line; do
              if [ -n "$line" ]; then
                # Extract branch from create-pull-request line using simple grep and sed
                if echo "$line" | grep -q '"type"[[:space:]]*:[[:space:]]*"create-pull-request"'; then
                  echo "Found create-pull-request line: $line"
                  # Extract branch value using sed
                  BRANCH_NAME=$(echo "$line" | sed -n 's/.*"branch"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
                  if [ -n "$BRANCH_NAME" ]; then
                    echo "Extracted branch name from create-pull-request: $BRANCH_NAME"
                    break
                  fi
                # Extract branch from push-to-pr-branch line using simple grep and sed
                elif echo "$line" | grep -q '"type"[[:space:]]*:[[:space:]]*"push-to-pr-branch"'; then
                  echo "Found push-to-pr-branch line: $line"
                  # Extract branch value using sed
                  BRANCH_NAME=$(echo "$line" | sed -n 's/.*"branch"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
                  if [ -n "$BRANCH_NAME" ]; then
                    echo "Extracted branch name from push-to-pr-branch: $BRANCH_NAME"
                    break
                  fi
                fi
              fi
            done < "$GITHUB_AW_SAFE_OUTPUTS"
          fi
          
          # If no branch or branch doesn't exist, no patch
          if [ -z "$BRANCH_NAME" ]; then
            echo "No branch found, no patch generation"
          fi
          
          # Get the initial commit SHA from the base branch of the pull request
          INITIAL_SHA="$GITHUB_SHA"
          echo "SHA: $GITHUB_SHA"
          echo "Base commit SHA: $INITIAL_SHA"
          
          # If we have a branch name, check if that branch exists and get its diff
          if [ -n "$BRANCH_NAME" ]; then
            echo "Looking for branch: $BRANCH_NAME"
            # Check if the branch exists
            if git show-ref --verify --quiet refs/heads/$BRANCH_NAME; then
              echo "Branch $BRANCH_NAME exists, generating patch from branch changes"
              
              # Check if origin/$BRANCH_NAME exists to use as base
              if git show-ref --verify --quiet refs/remotes/origin/$BRANCH_NAME; then
                echo "Using origin/$BRANCH_NAME as base for patch generation"
                BASE_REF="origin/$BRANCH_NAME"
              else
                echo "origin/$BRANCH_NAME does not exist, using merge-base with default branch"
                # Get the default branch name
                DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')
                echo "Default branch: $DEFAULT_BRANCH"
                # Find merge base between default branch and current branch
                BASE_REF=$(git merge-base origin/$DEFAULT_BRANCH $BRANCH_NAME)
                echo "Using merge-base as base: $BASE_REF"
              fi
              
              # Generate patch from the determined base to the branch
              git format-patch "$BASE_REF".."$BRANCH_NAME" --stdout > /tmp/aw.patch || echo "Failed to generate patch from branch" > /tmp/aw.patch
              echo "Patch file created from branch: $BRANCH_NAME (base: $BASE_REF)"
            else
              echo "Branch $BRANCH_NAME does not exist, no patch"
            fi
          fi
          
          # Show patch info if it exists
          if [ -f /tmp/aw.patch ]; then
            ls -la /tmp/aw.patch
            # Show the first 50 lines of the patch for review
            echo '## Git Patch' >> $GITHUB_STEP_SUMMARY
            echo '' >> $GITHUB_STEP_SUMMARY
            echo '```diff' >> $GITHUB_STEP_SUMMARY
            head -500 /tmp/aw.patch >> $GITHUB_STEP_SUMMARY || echo "Could not display patch contents" >> $GITHUB_STEP_SUMMARY
            echo '...' >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo '' >> $GITHUB_STEP_SUMMARY
          fi
      - name: Upload git patch
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: aw.patch
          path: /tmp/aw.patch
          if-no-files-found: ignore

  create_pull_request:
    needs: test-codex-create-pull-request
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    timeout-minutes: 10
    outputs:
      branch_name: ${{ steps.create_pull_request.outputs.branch_name }}
      pull_request_number: ${{ steps.create_pull_request.outputs.pull_request_number }}
      pull_request_url: ${{ steps.create_pull_request.outputs.pull_request_url }}
    steps:
      - name: Download patch artifact
        continue-on-error: true
        uses: actions/download-artifact@v5
        with:
          name: aw.patch
          path: /tmp/
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Configure Git credentials
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "${{ github.workflow }}"
          echo "Git configured with standard GitHub Actions identity"
      - name: Create Pull Request
        id: create_pull_request
        uses: actions/github-script@v8
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.test-codex-create-pull-request.outputs.output }}
          GITHUB_AW_WORKFLOW_ID: "test-codex-create-pull-request"
          GITHUB_AW_BASE_BRANCH: ${{ github.ref_name }}
          GITHUB_AW_PR_TITLE_PREFIX: "[codex-test] "
          GITHUB_AW_PR_LABELS: "codex,automation,bot"
          GITHUB_AW_PR_DRAFT: "true"
          GITHUB_AW_PR_IF_NO_CHANGES: "warn"
        with:
          script: |
            /** @type {typeof import("fs")} */
            const fs = require("fs");
            /** @type {typeof import("crypto")} */
            const crypto = require("crypto");
            const { execSync } = require("child_process");
            async function main() {
              // Check if we're in staged mode
              const isStaged = process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true";
              // Environment validation - fail early if required variables are missing
              const workflowId = process.env.GITHUB_AW_WORKFLOW_ID;
              if (!workflowId) {
                throw new Error("GITHUB_AW_WORKFLOW_ID environment variable is required");
              }
              const baseBranch = process.env.GITHUB_AW_BASE_BRANCH;
              if (!baseBranch) {
                throw new Error("GITHUB_AW_BASE_BRANCH environment variable is required");
              }
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT || "";
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
              }
              const ifNoChanges = process.env.GITHUB_AW_PR_IF_NO_CHANGES || "warn";
              // Check if patch file exists and has valid content
              if (!fs.existsSync("/tmp/aw.patch")) {
                const message =
                  "No patch file found - cannot create pull request without changes";
                // If in staged mode, still show preview
                if (isStaged) {
                  let summaryContent = "## 🎭 Staged Mode: Create Pull Request Preview\n\n";
                  summaryContent +=
                    "The following pull request would be created if staged mode was disabled:\n\n";
                  summaryContent += `**Status:** ⚠️ No patch file found\n\n`;
                  summaryContent += `**Message:** ${message}\n\n`;
                  // Write to step summary
                  await core.summary.addRaw(summaryContent).write();
                  core.info(
                    "📝 Pull request creation preview written to step summary (no patch file)"
                  );
                  return;
                }
                switch (ifNoChanges) {
                  case "error":
                    throw new Error(message);
                  case "ignore":
                    // Silent success - no console output
                    return;
                  case "warn":
                  default:
                    core.warning(message);
                    return;
                }
              }
              const patchContent = fs.readFileSync("/tmp/aw.patch", "utf8");
              // Check for actual error conditions (but allow empty patches as valid noop)
              if (patchContent.includes("Failed to generate patch")) {
                const message =
                  "Patch file contains error message - cannot create pull request without changes";
                // If in staged mode, still show preview
                if (isStaged) {
                  let summaryContent = "## 🎭 Staged Mode: Create Pull Request Preview\n\n";
                  summaryContent +=
                    "The following pull request would be created if staged mode was disabled:\n\n";
                  summaryContent += `**Status:** ⚠️ Patch file contains error\n\n`;
                  summaryContent += `**Message:** ${message}\n\n`;
                  // Write to step summary
                  await core.summary.addRaw(summaryContent).write();
                  core.info(
                    "📝 Pull request creation preview written to step summary (patch error)"
                  );
                  return;
                }
                switch (ifNoChanges) {
                  case "error":
                    throw new Error(message);
                  case "ignore":
                    // Silent success - no console output
                    return;
                  case "warn":
                  default:
                    core.warning(message);
                    return;
                }
              }
              // Empty patch is valid - behavior depends on if-no-changes configuration
              const isEmpty = !patchContent || !patchContent.trim();
              if (isEmpty && !isStaged) {
                const message =
                  "Patch file is empty - no changes to apply (noop operation)";
                switch (ifNoChanges) {
                  case "error":
                    throw new Error(
                      "No changes to push - failing as configured by if-no-changes: error"
                    );
                  case "ignore":
                    // Silent success - no console output
                    return;
                  case "warn":
                  default:
                    core.warning(message);
                    return;
                }
              }
              core.debug(`Agent output content length: ${outputContent.length}`);
              if (!isEmpty) {
                core.info("Patch content validation passed");
              } else {
                core.info("Patch file is empty - processing noop operation");
              }
              // Parse the validated output JSON
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(
                  `Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`
                );
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.warning("No valid items found in agent output");
                return;
              }
              // Find the create-pull-request item
              const pullRequestItem = validatedOutput.items.find(
                /** @param {any} item */ item => item.type === "create-pull-request"
              );
              if (!pullRequestItem) {
                core.warning("No create-pull-request item found in agent output");
                return;
              }
              core.debug(
                `Found create-pull-request item: title="${pullRequestItem.title}", bodyLength=${pullRequestItem.body.length}`
              );
              // If in staged mode, emit step summary instead of creating PR
              if (isStaged) {
                let summaryContent = "## 🎭 Staged Mode: Create Pull Request Preview\n\n";
                summaryContent +=
                  "The following pull request would be created if staged mode was disabled:\n\n";
                summaryContent += `**Title:** ${pullRequestItem.title || "No title provided"}\n\n`;
                summaryContent += `**Branch:** ${pullRequestItem.branch || "auto-generated"}\n\n`;
                summaryContent += `**Base:** ${baseBranch}\n\n`;
                if (pullRequestItem.body) {
                  summaryContent += `**Body:**\n${pullRequestItem.body}\n\n`;
                }
                if (fs.existsSync("/tmp/aw.patch")) {
                  const patchStats = fs.readFileSync("/tmp/aw.patch", "utf8");
                  if (patchStats.trim()) {
                    summaryContent += `**Changes:** Patch file exists with ${patchStats.split("\n").length} lines\n\n`;
                    summaryContent += `<details><summary>Show patch preview</summary>\n\n\`\`\`diff\n${patchStats.slice(0, 2000)}${patchStats.length > 2000 ? "\n... (truncated)" : ""}\n\`\`\`\n\n</details>\n\n`;
                  } else {
                    summaryContent += `**Changes:** No changes (empty patch)\n\n`;
                  }
                }
                // Write to step summary
                await core.summary.addRaw(summaryContent).write();
                core.info("📝 Pull request creation preview written to step summary");
                return;
              }
              // Extract title, body, and branch from the JSON item
              let title = pullRequestItem.title.trim();
              let bodyLines = pullRequestItem.body.split("\n");
              let branchName = pullRequestItem.branch
                ? pullRequestItem.branch.trim()
                : null;
              // If no title was found, use a default
              if (!title) {
                title = "Agent Output";
              }
              // Apply title prefix if provided via environment variable
              const titlePrefix = process.env.GITHUB_AW_PR_TITLE_PREFIX;
              if (titlePrefix && !title.startsWith(titlePrefix)) {
                title = titlePrefix + title;
              }
              // Add AI disclaimer with run id, run htmlurl
              const runId = context.runId;
              const runUrl = context.payload.repository
                ? `${context.payload.repository.html_url}/actions/runs/${runId}`
                : `https://github.com/actions/runs/${runId}`;
              bodyLines.push(
                ``,
                ``,
                `> Generated by Agentic Workflow [Run](${runUrl})`,
                ""
              );
              // Prepare the body content
              const body = bodyLines.join("\n").trim();
              // Parse labels from environment variable (comma-separated string)
              const labelsEnv = process.env.GITHUB_AW_PR_LABELS;
              const labels = labelsEnv
                ? labelsEnv
                    .split(",")
                    .map(/** @param {string} label */ label => label.trim())
                    .filter(/** @param {string} label */ label => label)
                : [];
              // Parse draft setting from environment variable (defaults to true)
              const draftEnv = process.env.GITHUB_AW_PR_DRAFT;
              const draft = draftEnv ? draftEnv.toLowerCase() === "true" : true;
              core.info(`Creating pull request with title: ${title}`);
              core.debug(`Labels: ${JSON.stringify(labels)}`);
              core.debug(`Draft: ${draft}`);
              core.debug(`Body length: ${body.length}`);
              const randomHex = crypto.randomBytes(8).toString("hex");
              // Use branch name from JSONL if provided, otherwise generate unique branch name
              if (!branchName) {
                core.debug(
                  "No branch name provided in JSONL, generating unique branch name"
                );
                // Generate unique branch name using cryptographic random hex
                branchName = `${workflowId}-${randomHex}`;
              } else {
                branchName = `${branchName}-${randomHex}`;
                core.debug(`Using branch name from JSONL with added salt: ${branchName}`);
              }
              core.info(`Generated branch name: ${branchName}`);
              core.debug(`Base branch: ${baseBranch}`);
              // Create a new branch using git CLI, ensuring it's based on the correct base branch
              // First, fetch latest changes and checkout the base branch
              core.debug(
                `Fetching latest changes and checking out base branch: ${baseBranch}`
              );
              execSync("git fetch origin", { stdio: "inherit" });
              execSync(`git checkout ${baseBranch}`, { stdio: "inherit" });
              // Handle branch creation/checkout
              core.debug(
                `Branch should not exist locally, creating new branch from base: ${branchName}`
              );
              execSync(`git checkout -b ${branchName}`, { stdio: "inherit" });
              core.info(`Created new branch from base: ${branchName}`);
              // Apply the patch using git CLI (skip if empty)
              if (!isEmpty) {
                core.info("Applying patch...");
                // Patches are created with git format-patch, so use git am to apply them
                execSync("git am /tmp/aw.patch", { stdio: "inherit" });
                core.info("Patch applied successfully");
                // Push the applied commits to the branch
                execSync(`git push origin ${branchName}`, { stdio: "inherit" });
                core.info("Changes pushed to branch");
              } else {
                core.info("Skipping patch application (empty patch)");
                // For empty patches, handle if-no-changes configuration
                const message =
                  "No changes to apply - noop operation completed successfully";
                switch (ifNoChanges) {
                  case "error":
                    throw new Error(
                      "No changes to apply - failing as configured by if-no-changes: error"
                    );
                  case "ignore":
                    // Silent success - no console output
                    return;
                  case "warn":
                  default:
                    core.warning(message);
                    return;
                }
              }
              // Create the pull request
              const { data: pullRequest } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                head: branchName,
                base: baseBranch,
                draft: draft,
              });
              core.info(
                `Created pull request #${pullRequest.number}: ${pullRequest.html_url}`
              );
              // Add labels if specified
              if (labels.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pullRequest.number,
                  labels: labels,
                });
                core.info(`Added labels to pull request: ${JSON.stringify(labels)}`);
              }
              // Set output for other jobs to use
              core.setOutput("pull_request_number", pullRequest.number);
              core.setOutput("pull_request_url", pullRequest.html_url);
              core.setOutput("branch_name", branchName);
              // Write summary to GitHub Actions summary
              await core.summary
                .addRaw(
                  `
            ## Pull Request
            - **Pull Request**: [#${pullRequest.number}](${pullRequest.html_url})
            - **Branch**: \`${branchName}\`
            - **Base Branch**: \`${baseBranch}\`
            `
                )
                .write();
            }
            await main();

