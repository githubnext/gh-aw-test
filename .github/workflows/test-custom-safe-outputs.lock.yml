# This file was automatically generated by gh-aw. DO NOT EDIT.
# To update this file, edit the corresponding .md file and run:
#   gh aw compile

name: "Test Safe Outputs - Custom Engine"
on:
  workflow_dispatch: null

permissions: {}

concurrency:
  group: "gh-aw-${{ github.workflow }}"

run-name: "Test Safe Outputs - Custom Engine"

jobs:
  test-safe-outputs-custom-engine:
    runs-on: ubuntu-latest
    permissions: read-all
    outputs:
      output: ${{ steps.collect_output.outputs.output }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
      - name: Configure Git credentials
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "${{ github.workflow }}"
          echo "Git configured with standard GitHub Actions identity"
      - name: Setup agent output
        id: setup_agent_output
        uses: actions/github-script@v7
        with:
          script: |
            function main() {
              const fs = require("fs");
              const crypto = require("crypto");
              // Generate a random filename for the output file
              const randomId = crypto.randomBytes(8).toString("hex");
              const outputFile = `/tmp/aw_output_${randomId}.txt`;
              // Ensure the /tmp directory exists
              fs.mkdirSync("/tmp", { recursive: true });
              // We don't create the file, as the name is sufficiently random
              // and some engines (Claude) fails first Write to the file
              // if it exists and has not been read.
              // Set the environment variable for subsequent steps
              core.exportVariable("GITHUB_AW_SAFE_OUTPUTS", outputFile);
              // Also set as step output for reference
              core.setOutput("output_file", outputFile);
            }
            main();
      - name: Setup Safe Outputs Collector MCP
        env:
          GITHUB_AW_SAFE_OUTPUTS_CONFIG: "{\"add-issue-comment\":{\"enabled\":true,\"target\":\"*\"},\"add-issue-label\":true,\"create-code-scanning-alert\":{\"enabled\":true,\"max\":5},\"create-discussion\":{\"enabled\":true,\"max\":1},\"create-issue\":true,\"create-pull-request\":true,\"create-pull-request-review-comment\":{\"enabled\":true,\"max\":1},\"missing-tool\":{\"enabled\":true,\"max\":5},\"push-to-pr-branch\":{\"enabled\":true,\"target\":\"*\"},\"update-issue\":true}"
        run: |
          cat >> $GITHUB_ENV << 'EOF'
          EOF
          mkdir -p /tmp/safe-outputs
          cat > /tmp/safe-outputs/mcp-server.cjs << 'EOF'
            const fs = require("fs");
            const encoder = new TextEncoder();
            const configEnv = process.env.GITHUB_AW_SAFE_OUTPUTS_CONFIG;
            if (!configEnv) throw new Error("GITHUB_AW_SAFE_OUTPUTS_CONFIG not set");
            const safeOutputsConfig = JSON.parse(configEnv);
            const outputFile = process.env.GITHUB_AW_SAFE_OUTPUTS;
            if (!outputFile)
              throw new Error("GITHUB_AW_SAFE_OUTPUTS not set, no output file");
            const SERVER_INFO = { name: "safe-outputs-mcp-server", version: "1.0.0" };
            function writeMessage(obj) {
              const json = JSON.stringify(obj);
              const bytes = encoder.encode(json);
              const header = `Content-Length: ${bytes.byteLength}\r\n\r\n`;
              const headerBytes = encoder.encode(header);
              fs.writeSync(1, headerBytes);
              fs.writeSync(1, bytes);
            }
            let buffer = Buffer.alloc(0);
            function onData(chunk) {
              buffer = Buffer.concat([buffer, chunk]);
              while (true) {
                const sep = buffer.indexOf("\r\n\r\n");
                if (sep === -1) break;
                const headerPart = buffer.slice(0, sep).toString("utf8");
                const match = headerPart.match(/Content-Length:\s*(\d+)/i);
                if (!match) {
                  buffer = buffer.slice(sep + 4);
                  continue;
                }
                const length = parseInt(match[1], 10);
                const total = sep + 4 + length;
                if (buffer.length < total) break; // wait for full body
                const body = buffer.slice(sep + 4, total);
                buffer = buffer.slice(total);
                try {
                  const msg = JSON.parse(body.toString("utf8"));
                  handleMessage(msg);
                } catch (e) {
                  const err = {
                    jsonrpc: "2.0",
                    id: null,
                    error: { code: -32700, message: "Parse error", data: String(e) },
                  };
                  writeMessage(err);
                }
              }
            }
            process.stdin.on("data", onData);
            process.stdin.on("error", () => {});
            process.stdin.resume();
            function replyResult(id, result) {
              if (id === undefined || id === null) return; // notification
              const res = { jsonrpc: "2.0", id, result };
              writeMessage(res);
            }
            function replyError(id, code, message, data) {
              const res = {
                jsonrpc: "2.0",
                id: id ?? null,
                error: { code, message, data },
              };
              writeMessage(res);
            }
            function isToolEnabled(name) {
              return safeOutputsConfig[name] && safeOutputsConfig[name].enabled;
            }
            function appendSafeOutput(entry) {
              if (!outputFile) throw new Error("No output file configured");
              const jsonLine = JSON.stringify(entry) + "\n";
              try {
                fs.appendFileSync(outputFile, jsonLine);
              } catch (error) {
                throw new Error(
                  `Failed to write to output file: ${error instanceof Error ? error.message : String(error)}`
                );
              }
            }
            const defaultHandler = type => async args => {
              const entry = { ...(args || {}), type };
              appendSafeOutput(entry);
              return {
                content: [
                  {
                    type: "text",
                    text: `success`,
                  },
                ],
              };
            };
            const TOOLS = Object.fromEntries(
              [
                {
                  name: "create-issue",
                  description: "Create a new GitHub issue",
                  inputSchema: {
                    type: "object",
                    required: ["title", "body"],
                    properties: {
                      title: { type: "string", description: "Issue title" },
                      body: { type: "string", description: "Issue body/description" },
                      labels: {
                        type: "array",
                        items: { type: "string" },
                        description: "Issue labels",
                      },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "create-discussion",
                  description: "Create a new GitHub discussion",
                  inputSchema: {
                    type: "object",
                    required: ["title", "body"],
                    properties: {
                      title: { type: "string", description: "Discussion title" },
                      body: { type: "string", description: "Discussion body/content" },
                      category: { type: "string", description: "Discussion category" },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "add-issue-comment",
                  description: "Add a comment to a GitHub issue or pull request",
                  inputSchema: {
                    type: "object",
                    required: ["body"],
                    properties: {
                      body: { type: "string", description: "Comment body/content" },
                      issue_number: {
                        type: "number",
                        description: "Issue or PR number (optional for current context)",
                      },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "create-pull-request",
                  description: "Create a new GitHub pull request",
                  inputSchema: {
                    type: "object",
                    required: ["title", "body"],
                    properties: {
                      title: { type: "string", description: "Pull request title" },
                      body: {
                        type: "string",
                        description: "Pull request body/description",
                      },
                      branch: {
                        type: "string",
                        description:
                          "Optional branch name (will be auto-generated if not provided)",
                      },
                      labels: {
                        type: "array",
                        items: { type: "string" },
                        description: "Optional labels to add to the PR",
                      },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "create-pull-request-review-comment",
                  description: "Create a review comment on a GitHub pull request",
                  inputSchema: {
                    type: "object",
                    required: ["path", "line", "body"],
                    properties: {
                      path: {
                        type: "string",
                        description: "File path for the review comment",
                      },
                      line: {
                        type: ["number", "string"],
                        description: "Line number for the comment",
                      },
                      body: { type: "string", description: "Comment body content" },
                      start_line: {
                        type: ["number", "string"],
                        description: "Optional start line for multi-line comments",
                      },
                      side: {
                        type: "string",
                        enum: ["LEFT", "RIGHT"],
                        description: "Optional side of the diff: LEFT or RIGHT",
                      },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "create-code-scanning-alert",
                  description: "Create a code scanning alert",
                  inputSchema: {
                    type: "object",
                    required: ["file", "line", "severity", "message"],
                    properties: {
                      file: {
                        type: "string",
                        description: "File path where the issue was found",
                      },
                      line: {
                        type: ["number", "string"],
                        description: "Line number where the issue was found",
                      },
                      severity: {
                        type: "string",
                        enum: ["error", "warning", "info", "note"],
                        description: "Severity level",
                      },
                      message: {
                        type: "string",
                        description: "Alert message describing the issue",
                      },
                      column: {
                        type: ["number", "string"],
                        description: "Optional column number",
                      },
                      ruleIdSuffix: {
                        type: "string",
                        description: "Optional rule ID suffix for uniqueness",
                      },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "add-issue-label",
                  description: "Add labels to a GitHub issue or pull request",
                  inputSchema: {
                    type: "object",
                    required: ["labels"],
                    properties: {
                      labels: {
                        type: "array",
                        items: { type: "string" },
                        description: "Labels to add",
                      },
                      issue_number: {
                        type: "number",
                        description: "Issue or PR number (optional for current context)",
                      },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "update-issue",
                  description: "Update a GitHub issue",
                  inputSchema: {
                    type: "object",
                    properties: {
                      status: {
                        type: "string",
                        enum: ["open", "closed"],
                        description: "Optional new issue status",
                      },
                      title: { type: "string", description: "Optional new issue title" },
                      body: { type: "string", description: "Optional new issue body" },
                      issue_number: {
                        type: ["number", "string"],
                        description: "Optional issue number for target '*'",
                      },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "push-to-pr-branch",
                  description: "Push changes to a pull request branch",
                  inputSchema: {
                    type: "object",
                    properties: {
                      message: { type: "string", description: "Optional commit message" },
                      pull_request_number: {
                        type: ["number", "string"],
                        description: "Optional pull request number for target '*'",
                      },
                    },
                    additionalProperties: false,
                  },
                },
                {
                  name: "missing-tool",
                  description:
                    "Report a missing tool or functionality needed to complete tasks",
                  inputSchema: {
                    type: "object",
                    required: ["tool", "reason"],
                    properties: {
                      tool: { type: "string", description: "Name of the missing tool" },
                      reason: { type: "string", description: "Why this tool is needed" },
                      alternatives: {
                        type: "string",
                        description: "Possible alternatives or workarounds",
                      },
                    },
                    additionalProperties: false,
                  },
                },
              ]
                .filter(({ name }) => isToolEnabled(name))
                .map(tool => [tool.name, tool])
            );
            process.stderr.write(
              `[${SERVER_INFO.name}] v${SERVER_INFO.version} ready on stdio\n`
            );
            process.stderr.write(`[${SERVER_INFO.name}]  output file: ${outputFile}\n`);
            process.stderr.write(
              `[${SERVER_INFO.name}]  config: ${JSON.stringify(safeOutputsConfig)}\n`
            );
            process.stderr.write(
              `[${SERVER_INFO.name}]  tools: ${Object.keys(TOOLS).join(", ")}\n`
            );
            if (!Object.keys(TOOLS).length)
              throw new Error("No tools enabled in configuration");
            function handleMessage(req) {
              const { id, method, params } = req;
              try {
                if (method === "initialize") {
                  const clientInfo = params?.clientInfo ?? {};
                  console.error(`client initialized:`, clientInfo);
                  const protocolVersion = params?.protocolVersion ?? undefined;
                  const result = {
                    serverInfo: SERVER_INFO,
                    ...(protocolVersion ? { protocolVersion } : {}),
                    capabilities: {
                      tools: {},
                    },
                  };
                  replyResult(id, result);
                } else if (method === "tools/list") {
                  const list = [];
                  Object.values(TOOLS).forEach(tool => {
                    list.push({
                      name: tool.name,
                      description: tool.description,
                      inputSchema: tool.inputSchema,
                    });
                  });
                  replyResult(id, { tools: list });
                } else if (method === "tools/call") {
                  const name = params?.name;
                  const args = params?.arguments ?? {};
                  if (!name || typeof name !== "string") {
                    replyError(id, -32602, "Invalid params: 'name' must be a string");
                    return;
                  }
                  const tool = TOOLS[name];
                  if (!tool) {
                    replyError(id, -32601, `Tool not found: ${name}`);
                    return;
                  }
                  const handler = tool.handler || defaultHandler(tool.name);
                  // Basic input validation: ensure required fields are present when schema defines them
                  const requiredFields =
                    tool.inputSchema && Array.isArray(tool.inputSchema.required)
                      ? tool.inputSchema.required
                      : [];
                  if (requiredFields.length) {
                    const missing = requiredFields.filter(f => args[f] === undefined);
                    if (missing.length) {
                      replyError(
                        id,
                        -32602,
                        `Invalid arguments: missing ${missing.map(m => `'${m}'`).join(", ")}`
                      );
                      return;
                    }
                  }
                  (async () => {
                    try {
                      const result = await handler(args);
                      // Handler is expected to return an object possibly containing 'content'.
                      // If handler returns a primitive or undefined, send an empty content array
                      const content = result && result.content ? result.content : [];
                      replyResult(id, { content });
                    } catch (e) {
                      replyError(id, -32000, `Tool '${name}' failed`, {
                        message: e instanceof Error ? e.message : String(e),
                      });
                    }
                  })();
                  return;
                }
                replyError(id, -32601, `Method not found: ${method}`);
              } catch (e) {
                replyError(id, -32603, "Internal error", {
                  message: e instanceof Error ? e.message : String(e),
                });
              }
            }
            process.stderr.write(`[${SERVER_INFO.name}] listening...\n`);
          EOF
          chmod +x /tmp/safe-outputs/mcp-server.cjs
          
      - name: Setup MCPs
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_AW_SAFE_OUTPUTS_CONFIG: "{\"add-issue-comment\":{\"enabled\":true,\"target\":\"*\"},\"add-issue-label\":true,\"create-code-scanning-alert\":{\"enabled\":true,\"max\":5},\"create-discussion\":{\"enabled\":true,\"max\":1},\"create-issue\":true,\"create-pull-request\":true,\"create-pull-request-review-comment\":{\"enabled\":true,\"max\":1},\"missing-tool\":{\"enabled\":true,\"max\":5},\"push-to-pr-branch\":{\"enabled\":true,\"target\":\"*\"},\"update-issue\":true}"
        run: |
          mkdir -p /tmp/mcp-config
          cat > /tmp/mcp-config/mcp-servers.json << 'EOF'
          {
            "mcpServers": {
              "safe_outputs": {
                "command": "node",
                "args": ["/tmp/safe-outputs/mcp-server.cjs"],
                "env": {
                  "GITHUB_AW_SAFE_OUTPUTS": "${GITHUB_AW_SAFE_OUTPUTS}",
                  "GITHUB_AW_SAFE_OUTPUTS_CONFIG": "${GITHUB_AW_SAFE_OUTPUTS_CONFIG}"
                }
              },
              "github": {
                "command": "docker",
                "args": [
                  "run",
                  "-i",
                  "--rm",
                  "-e",
                  "GITHUB_PERSONAL_ACCESS_TOKEN",
                  "ghcr.io/github/github-mcp-server:sha-09deac4"
                ],
                "env": {
                  "GITHUB_PERSONAL_ACCESS_TOKEN": "${{ secrets.GITHUB_TOKEN }}"
                }
              },
            }
          }
          EOF
      - name: Create prompt
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
        run: |
          mkdir -p /tmp/aw-prompts
          cat > $GITHUB_AW_PROMPT << 'EOF'
          # Test Safe Outputs - Custom Engine
          
          This workflow validates all safe output types using the custom engine implementation. It demonstrates the ability to use GitHub Actions steps directly in agentic workflows while leveraging the safe output processing system.
          
          ## Purpose
          
          This is a comprehensive test workflow that exercises every available safe output type:
          
          - **create-issue**: Creates test issues with custom engine
          - **add-issue-comment**: Posts comments on issues/PRs
          - **create-pull-request**: Creates PRs with code changes
          - **add-issue-label**: Adds labels to issues/PRs
          - **update-issue**: Updates issue properties
          - **push-to-pr-branch**: Pushes changes to branches
          - **missing-tool**: Reports missing functionality (test simulation)
          - **create-discussion**: Creates repository discussions
          - **create-pull-request-review-comment**: Creates PR review comments
          - **create-code-scanning-alert**: Generates SARIF repository security advisories
          
          ## Custom Engine Implementation
          
          The workflow uses the custom engine with GitHub Actions steps to generate all the required safe output files. Each step creates the appropriate output file with test content that demonstrates the functionality.
          
          ## Test Content
          
          All generated content is clearly marked as test data and includes:
          - Timestamp information
          - Trigger event details
          - Workflow identification
          - Clear indication that it's test data
          
          The content can be safely created and cleaned up as part of testing the safe output functionality.
          
          
          ---
          
          ## Adding a Comment to an Issue or Pull Request, Creating an Issue, Creating a Pull Request, Adding Labels to Issues or Pull Requests, Updating Issues, Pushing Changes to Branch, Creating Repository Security Advisories, Reporting Missing Tools or Functionality
          
          **IMPORTANT**: To do the actions mentioned in the header of this section, use the **safe-outputs** tools, do NOT attempt to use `gh`, do NOT attempt to use the GitHub API. You don't have write access to the GitHub repo.
          EOF
      - name: Print prompt to step summary
        run: |
          echo "## Generated Prompt" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````markdown' >> $GITHUB_STEP_SUMMARY
          cat $GITHUB_AW_PROMPT >> $GITHUB_STEP_SUMMARY
          echo '``````' >> $GITHUB_STEP_SUMMARY
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
      - name: Generate agentic run info
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            const awInfo = {
              engine_id: "custom",
              engine_name: "Custom Steps",
              model: "",
              version: "",
              workflow_name: "Test Safe Outputs - Custom Engine",
              experimental: false,
              supports_tools_whitelist: false,
              supports_http_transport: false,
              run_id: context.runId,
              run_number: context.runNumber,
              run_attempt: process.env.GITHUB_RUN_ATTEMPT,
              repository: context.repo.owner + '/' + context.repo.repo,
              ref: context.ref,
              sha: context.sha,
              actor: context.actor,
              event_name: context.eventName,
              staged: false,
              created_at: new Date().toISOString()
            };
            
            // Write to /tmp directory to avoid inclusion in PR
            const tmpPath = '/tmp/aw_info.json';
            fs.writeFileSync(tmpPath, JSON.stringify(awInfo, null, 2));
            console.log('Generated aw_info.json at:', tmpPath);
            console.log(JSON.stringify(awInfo, null, 2));
      - name: Upload agentic run info
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: aw_info.json
          path: /tmp/aw_info.json
          if-no-files-found: warn
      - name: Generate Create Issue Output
        run: |
          echo '{"type": "create-issue", "title": "[Custom Engine Test] Test Issue Created by Custom Engine", "body": "# Test Issue Created by Custom Engine\n\nThis issue was automatically created by the test-safe-outputs-custom-engine workflow to validate the create-issue safe output functionality.\n\n**Test Details:**\n- Engine: Custom\n- Trigger: ${{ github.event_name }}\n- Repository: ${{ github.repository }}\n- Run ID: ${{ github.run_id }}\n\nThis is a test issue and can be closed after verification.", "labels": ["test-safe-outputs", "automation", "custom-engine"]}' >> $GITHUB_AW_SAFE_OUTPUTS
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
      - name: Generate Add Issue Comment Output
        run: |
          echo '{"type": "add-issue-comment", "body": "## Test Comment from Custom Engine\n\nThis comment was automatically posted by the test-safe-outputs-custom-engine workflow to validate the add-issue-comment safe output functionality.\n\n**Test Information:**\n- Workflow: test-safe-outputs-custom-engine\n- Engine Type: Custom (GitHub Actions steps)\n- Execution Time: '"$(date)"'\n- Event: ${{ github.event_name }}\n\n✅ Safe output testing in progress..."}' >> $GITHUB_AW_SAFE_OUTPUTS
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
      - name: Generate Add Issue Labels Output
        run: |
          echo '{"type": "add-issue-label", "labels": ["test-safe-outputs", "automation", "custom-engine"]}' >> $GITHUB_AW_SAFE_OUTPUTS
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
      - name: Generate Update Issue Output
        run: |
          echo '{"type": "update-issue", "title": "[UPDATED] Test Issue - Custom Engine Safe Output Test", "body": "# Updated Issue Body\n\nThis issue has been updated by the test-safe-outputs-custom-engine workflow to validate the update-issue safe output functionality.\n\n**Update Details:**\n- Updated by: Custom Engine\n- Update time: '"$(date)"'\n- Original trigger: ${{ github.event_name }}\n\n**Test Status:** ✅ Update functionality verified", "status": "open"}' >> $GITHUB_AW_SAFE_OUTPUTS
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
      - name: Generate Create Pull Request Output
        run: |
          # Create a test file change
          echo "# Test file created by custom engine safe output test" > test-custom-engine-$(date +%Y%m%d-%H%M%S).md
          echo "This file was created to test the create-pull-request safe output." >> test-custom-engine-$(date +%Y%m%d-%H%M%S).md
          echo "Generated at: $(date)" >> test-custom-engine-$(date +%Y%m%d-%H%M%S).md

          # Create PR output
          echo '{"type": "create-pull-request", "title": "[Custom Engine Test] Test Pull Request - Custom Engine Safe Output", "body": "# Test Pull Request - Custom Engine Safe Output\n\nThis pull request was automatically created by the test-safe-outputs-custom-engine workflow to validate the create-pull-request safe output functionality.\n\n## Changes Made\n- Created test file with timestamp\n- Demonstrates custom engine file creation capabilities\n\n## Test Information\n- Engine: Custom (GitHub Actions steps)\n- Workflow: test-safe-outputs-custom-engine\n- Trigger Event: ${{ github.event_name }}\n- Run ID: ${{ github.run_id }}\n\nThis PR can be merged or closed after verification of the safe output functionality.", "labels": ["test-safe-outputs", "automation", "custom-engine"], "draft": true}' >> $GITHUB_AW_SAFE_OUTPUTS
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
      - name: Generate Create Discussion Output
        run: |
          echo '{"type": "create-discussion", "title": "[Custom Engine Test] Test Discussion - Custom Engine Safe Output", "body": "# Test Discussion - Custom Engine Safe Output\n\nThis discussion was automatically created by the test-safe-outputs-custom-engine workflow to validate the create-discussion safe output functionality.\n\n## Purpose\nThis discussion serves as a test of the safe output systems ability to create GitHub discussions through custom engine workflows.\n\n## Test Details\n- **Engine Type:** Custom (GitHub Actions steps)\n- **Workflow:** test-safe-outputs-custom-engine\n- **Created:** '"$(date)"'\n- **Trigger:** ${{ github.event_name }}\n- **Repository:** ${{ github.repository }}\n\n## Discussion Points\n1. Custom engine successfully executed\n2. Safe output file generation completed\n3. Discussion creation triggered\n\nFeel free to participate in this test discussion or archive it after verification."}' >> $GITHUB_AW_SAFE_OUTPUTS
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
      - name: Generate PR Review Comment Output
        run: |
          echo '{"type": "create-pull-request-review-comment", "path": "README.md", "line": 1, "body": "## Custom Engine Review Comment Test\n\nThis review comment was automatically created by the test-safe-outputs-custom-engine workflow to validate the create-pull-request-review-comment safe output functionality.\n\n**Review Details:**\n- Generated by: Custom Engine\n- Test time: '"$(date)"'\n- Workflow: test-safe-outputs-custom-engine\n\n✅ PR review comment safe output test completed."}' >> $GITHUB_AW_SAFE_OUTPUTS
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
      - name: Generate Push to Branch Output
        run: |
          # Create another test file for branch push
          echo "# Branch Push Test File" > branch-push-test-$(date +%Y%m%d-%H%M%S).md
          echo "This file tests the push-to-pr-branch safe output functionality." >> branch-push-test-$(date +%Y%m%d-%H%M%S).md
          echo "Created by custom engine at: $(date)" >> branch-push-test-$(date +%Y%m%d-%H%M%S).md

          echo '{"type": "push-to-pr-branch", "message": "Custom engine test: Push to branch functionality\n\nThis commit was generated by the test-safe-outputs-custom-engine workflow to validate the push-to-pr-branch safe output functionality.\n\nFiles created:\n- branch-push-test-[timestamp].md\n\nTest executed at: '"$(date)"'"}' >> $GITHUB_AW_SAFE_OUTPUTS
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
      - name: Generate Missing Tool Output
        run: |
          echo '{"type": "missing-tool", "tool": "example-missing-tool", "reason": "This is a test of the missing-tool safe output functionality. No actual tool is missing.", "alternatives": "This is a simulated missing tool report generated by the custom engine test workflow.", "context": "test-safe-outputs-custom-engine workflow validation"}' >> $GITHUB_AW_SAFE_OUTPUTS
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
      - name: Generate Code Scanning Alert Output
        run: |
          echo '{"type": "create-code-scanning-alert", "file": "README.md", "line": 1, "severity": "note", "message": "This is a test security finding generated by the custom engine workflow to validate the create-code-scanning-alert safe output functionality. This is a notice-level finding used for testing purposes and does not represent an actual security issue.", "ruleIdSuffix": "test-custom-engine-notice"}' >> $GITHUB_AW_SAFE_OUTPUTS
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
      - name: List generated outputs
        run: |
          echo "Generated safe output entries:"
          if [ -f "$GITHUB_AW_SAFE_OUTPUTS" ]; then
            cat "$GITHUB_AW_SAFE_OUTPUTS"
          else
            echo "No safe outputs file found"
          fi

          echo "Additional test files created:"
          ls -la *.md 2>/dev/null || echo "No additional .md files found"
        env:
          GITHUB_AW_PROMPT: /tmp/aw-prompts/prompt.txt
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
      - name: Ensure log file exists
        run: |
          echo "Custom steps execution completed" >> /tmp/test-safe-outputs-custom-engine.log
          touch /tmp/test-safe-outputs-custom-engine.log
      - name: Print Agent output
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
        run: |
          echo "## Agent Output (JSONL)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````json' >> $GITHUB_STEP_SUMMARY
          if [ -f ${{ env.GITHUB_AW_SAFE_OUTPUTS }} ]; then
            cat ${{ env.GITHUB_AW_SAFE_OUTPUTS }} >> $GITHUB_STEP_SUMMARY
            # Ensure there's a newline after the file content if it doesn't end with one
            if [ -s ${{ env.GITHUB_AW_SAFE_OUTPUTS }} ] && [ "$(tail -c1 ${{ env.GITHUB_AW_SAFE_OUTPUTS }})" != "" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "No agent output file found" >> $GITHUB_STEP_SUMMARY
          fi
          echo '``````' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
      - name: Upload agentic output file
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: safe_output.jsonl
          path: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          if-no-files-found: warn
      - name: Ingest agent output
        id: collect_output
        uses: actions/github-script@v7
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_AW_SAFE_OUTPUTS_CONFIG: "{\"add-issue-comment\":{\"enabled\":true,\"target\":\"*\"},\"add-issue-label\":true,\"create-code-scanning-alert\":{\"enabled\":true,\"max\":5},\"create-discussion\":{\"enabled\":true,\"max\":1},\"create-issue\":true,\"create-pull-request\":true,\"create-pull-request-review-comment\":{\"enabled\":true,\"max\":1},\"missing-tool\":{\"enabled\":true,\"max\":5},\"push-to-pr-branch\":{\"enabled\":true,\"target\":\"*\"},\"update-issue\":true}"
        with:
          script: |
            async function main() {
              const fs = require("fs");
              /**
               * Sanitizes content for safe output in GitHub Actions
               * @param {string} content - The content to sanitize
               * @returns {string} The sanitized content
               */
              function sanitizeContent(content) {
                if (!content || typeof content !== "string") {
                  return "";
                }
                // Read allowed domains from environment variable
                const allowedDomainsEnv = process.env.GITHUB_AW_ALLOWED_DOMAINS;
                const defaultAllowedDomains = [
                  "github.com",
                  "github.io",
                  "githubusercontent.com",
                  "githubassets.com",
                  "github.dev",
                  "codespaces.new",
                ];
                const allowedDomains = allowedDomainsEnv
                  ? allowedDomainsEnv
                      .split(",")
                      .map(d => d.trim())
                      .filter(d => d)
                  : defaultAllowedDomains;
                let sanitized = content;
                // Neutralize @mentions to prevent unintended notifications
                sanitized = neutralizeMentions(sanitized);
                // Remove control characters (except newlines and tabs)
                sanitized = sanitized.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, "");
                // XML character escaping
                sanitized = sanitized
                  .replace(/&/g, "&amp;") // Must be first to avoid double-escaping
                  .replace(/</g, "&lt;")
                  .replace(/>/g, "&gt;")
                  .replace(/"/g, "&quot;")
                  .replace(/'/g, "&apos;");
                // URI filtering - replace non-https protocols with "(redacted)"
                sanitized = sanitizeUrlProtocols(sanitized);
                // Domain filtering for HTTPS URIs
                sanitized = sanitizeUrlDomains(sanitized);
                // Limit total length to prevent DoS (0.5MB max)
                const maxLength = 524288;
                if (sanitized.length > maxLength) {
                  sanitized =
                    sanitized.substring(0, maxLength) +
                    "\n[Content truncated due to length]";
                }
                // Limit number of lines to prevent log flooding (65k max)
                const lines = sanitized.split("\n");
                const maxLines = 65000;
                if (lines.length > maxLines) {
                  sanitized =
                    lines.slice(0, maxLines).join("\n") +
                    "\n[Content truncated due to line count]";
                }
                // Remove ANSI escape sequences
                sanitized = sanitized.replace(/\x1b\[[0-9;]*[mGKH]/g, "");
                // Neutralize common bot trigger phrases
                sanitized = neutralizeBotTriggers(sanitized);
                // Trim excessive whitespace
                return sanitized.trim();
                /**
                 * Remove unknown domains
                 * @param {string} s - The string to process
                 * @returns {string} The string with unknown domains redacted
                 */
                function sanitizeUrlDomains(s) {
                  return s.replace(
                    /\bhttps:\/\/([^\/\s\])}'"<>&\x00-\x1f]+)/gi,
                    (match, domain) => {
                      // Extract the hostname part (before first slash, colon, or other delimiter)
                      const hostname = domain.split(/[\/:\?#]/)[0].toLowerCase();
                      // Check if this domain or any parent domain is in the allowlist
                      const isAllowed = allowedDomains.some(allowedDomain => {
                        const normalizedAllowed = allowedDomain.toLowerCase();
                        return (
                          hostname === normalizedAllowed ||
                          hostname.endsWith("." + normalizedAllowed)
                        );
                      });
                      return isAllowed ? match : "(redacted)";
                    }
                  );
                }
                /**
                 * Remove unknown protocols except https
                 * @param {string} s - The string to process
                 * @returns {string} The string with non-https protocols redacted
                 */
                function sanitizeUrlProtocols(s) {
                  // Match both protocol:// and protocol: patterns
                  return s.replace(
                    /\b(\w+):(?:\/\/)?[^\s\])}'"<>&\x00-\x1f]+/gi,
                    (match, protocol) => {
                      // Allow https (case insensitive), redact everything else
                      return protocol.toLowerCase() === "https" ? match : "(redacted)";
                    }
                  );
                }
                /**
                 * Neutralizes @mentions by wrapping them in backticks
                 * @param {string} s - The string to process
                 * @returns {string} The string with neutralized mentions
                 */
                function neutralizeMentions(s) {
                  // Replace @name or @org/team outside code with `@name`
                  return s.replace(
                    /(^|[^\w`])@([A-Za-z0-9](?:[A-Za-z0-9-]{0,37}[A-Za-z0-9])?(?:\/[A-Za-z0-9._-]+)?)/g,
                    (_m, p1, p2) => `${p1}\`@${p2}\``
                  );
                }
                /**
                 * Neutralizes bot trigger phrases by wrapping them in backticks
                 * @param {string} s - The string to process
                 * @returns {string} The string with neutralized bot triggers
                 */
                function neutralizeBotTriggers(s) {
                  // Neutralize common bot trigger phrases like "fixes #123", "closes #asdfs", etc.
                  return s.replace(
                    /\b(fixes?|closes?|resolves?|fix|close|resolve)\s+#(\w+)/gi,
                    (match, action, ref) => `\`${action} #${ref}\``
                  );
                }
              }
              /**
               * Gets the maximum allowed count for a given output type
               * @param {string} itemType - The output item type
               * @param {any} config - The safe-outputs configuration
               * @returns {number} The maximum allowed count
               */
              function getMaxAllowedForType(itemType, config) {
                // Check if max is explicitly specified in config
                if (
                  config &&
                  config[itemType] &&
                  typeof config[itemType] === "object" &&
                  config[itemType].max
                ) {
                  return config[itemType].max;
                }
                // Use default limits for plural-supported types
                switch (itemType) {
                  case "create-issue":
                    return 1; // Only one issue allowed
                  case "add-issue-comment":
                    return 1; // Only one comment allowed
                  case "create-pull-request":
                    return 1; // Only one pull request allowed
                  case "create-pull-request-review-comment":
                    return 10; // Default to 10 review comments allowed
                  case "add-issue-label":
                    return 5; // Only one labels operation allowed
                  case "update-issue":
                    return 1; // Only one issue update allowed
                  case "push-to-pr-branch":
                    return 1; // Only one push to branch allowed
                  case "create-discussion":
                    return 1; // Only one discussion allowed
                  case "missing-tool":
                    return 1000; // Allow many missing tool reports (default: unlimited)
                  case "create-code-scanning-alert":
                    return 1000; // Allow many repository security advisories (default: unlimited)
                  default:
                    return 1; // Default to single item for unknown types
                }
              }
              /**
               * Attempts to repair common JSON syntax issues in LLM-generated content
               * @param {string} jsonStr - The potentially malformed JSON string
               * @returns {string} The repaired JSON string
               */
              function repairJson(jsonStr) {
                let repaired = jsonStr.trim();
                // remove invalid control characters like
                // U+0014 (DC4) — represented here as "\u0014"
                // Escape control characters not allowed in JSON strings (U+0000 through U+001F)
                // Preserve common JSON escapes for \b, \f, \n, \r, \t and use \uXXXX for the rest.
                /** @type {Record<number, string>} */
                const _ctrl = { 8: "\\b", 9: "\\t", 10: "\\n", 12: "\\f", 13: "\\r" };
                repaired = repaired.replace(/[\u0000-\u001F]/g, ch => {
                  const c = ch.charCodeAt(0);
                  return _ctrl[c] || "\\u" + c.toString(16).padStart(4, "0");
                });
                // Fix single quotes to double quotes (must be done first)
                repaired = repaired.replace(/'/g, '"');
                // Fix missing quotes around object keys
                repaired = repaired.replace(
                  /([{,]\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\s*:/g,
                  '$1"$2":'
                );
                // Fix newlines and tabs inside strings by escaping them
                repaired = repaired.replace(/"([^"\\]*)"/g, (match, content) => {
                  if (
                    content.includes("\n") ||
                    content.includes("\r") ||
                    content.includes("\t")
                  ) {
                    const escaped = content
                      .replace(/\\/g, "\\\\")
                      .replace(/\n/g, "\\n")
                      .replace(/\r/g, "\\r")
                      .replace(/\t/g, "\\t");
                    return `"${escaped}"`;
                  }
                  return match;
                });
                // Fix unescaped quotes inside string values
                repaired = repaired.replace(
                  /"([^"]*)"([^":,}\]]*)"([^"]*)"(\s*[,:}\]])/g,
                  (match, p1, p2, p3, p4) => `"${p1}\\"${p2}\\"${p3}"${p4}`
                );
                // Fix wrong bracket/brace types - arrays should end with ] not }
                repaired = repaired.replace(
                  /(\[\s*(?:"[^"]*"(?:\s*,\s*"[^"]*")*\s*),?)\s*}/g,
                  "$1]"
                );
                // Fix missing closing braces/brackets
                const openBraces = (repaired.match(/\{/g) || []).length;
                const closeBraces = (repaired.match(/\}/g) || []).length;
                if (openBraces > closeBraces) {
                  repaired += "}".repeat(openBraces - closeBraces);
                } else if (closeBraces > openBraces) {
                  repaired = "{".repeat(closeBraces - openBraces) + repaired;
                }
                // Fix missing closing brackets for arrays
                const openBrackets = (repaired.match(/\[/g) || []).length;
                const closeBrackets = (repaired.match(/\]/g) || []).length;
                if (openBrackets > closeBrackets) {
                  repaired += "]".repeat(openBrackets - closeBrackets);
                } else if (closeBrackets > openBrackets) {
                  repaired = "[".repeat(closeBrackets - openBrackets) + repaired;
                }
                // Fix trailing commas in objects and arrays (AFTER fixing brackets/braces)
                repaired = repaired.replace(/,(\s*[}\]])/g, "$1");
                return repaired;
              }
              /**
               * Attempts to parse JSON with repair fallback
               * @param {string} jsonStr - The JSON string to parse
               * @returns {Object|undefined} The parsed JSON object, or undefined if parsing fails
               */
              function parseJsonWithRepair(jsonStr) {
                try {
                  // First, try normal JSON.parse
                  return JSON.parse(jsonStr);
                } catch (originalError) {
                  try {
                    // If that fails, try repairing and parsing again
                    const repairedJson = repairJson(jsonStr);
                    return JSON.parse(repairedJson);
                  } catch (repairError) {
                    // If repair also fails, throw the error
                    core.info(`invalid input json: ${jsonStr}`);
                    const originalMsg =
                      originalError instanceof Error
                        ? originalError.message
                        : String(originalError);
                    const repairMsg =
                      repairError instanceof Error
                        ? repairError.message
                        : String(repairError);
                    throw new Error(
                      `JSON parsing failed. Original: ${originalMsg}. After attempted repair: ${repairMsg}`
                    );
                  }
                }
              }
              const outputFile = process.env.GITHUB_AW_SAFE_OUTPUTS;
              const safeOutputsConfig = process.env.GITHUB_AW_SAFE_OUTPUTS_CONFIG;
              if (!outputFile) {
                core.info("GITHUB_AW_SAFE_OUTPUTS not set, no output to collect");
                core.setOutput("output", "");
                return;
              }
              if (!fs.existsSync(outputFile)) {
                core.info(`Output file does not exist: ${outputFile}`);
                core.setOutput("output", "");
                return;
              }
              const outputContent = fs.readFileSync(outputFile, "utf8");
              if (outputContent.trim() === "") {
                core.info("Output file is empty");
                core.setOutput("output", "");
                return;
              }
              core.info(`Raw output content length: ${outputContent.length}`);
              // Parse the safe-outputs configuration
              /** @type {any} */
              let expectedOutputTypes = {};
              if (safeOutputsConfig) {
                try {
                  expectedOutputTypes = JSON.parse(safeOutputsConfig);
                  core.info(
                    `Expected output types: ${JSON.stringify(Object.keys(expectedOutputTypes))}`
                  );
                } catch (error) {
                  const errorMsg = error instanceof Error ? error.message : String(error);
                  core.info(`Warning: Could not parse safe-outputs config: ${errorMsg}`);
                }
              }
              // Parse JSONL content
              const lines = outputContent.trim().split("\n");
              const parsedItems = [];
              const errors = [];
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === "") continue; // Skip empty lines
                try {
                  /** @type {any} */
                  const item = parseJsonWithRepair(line);
                  // If item is undefined (failed to parse), add error and process next line
                  if (item === undefined) {
                    errors.push(`Line ${i + 1}: Invalid JSON - JSON parsing failed`);
                    continue;
                  }
                  // Validate that the item has a 'type' field
                  if (!item.type) {
                    errors.push(`Line ${i + 1}: Missing required 'type' field`);
                    continue;
                  }
                  // Validate against expected output types
                  const itemType = item.type;
                  if (!expectedOutputTypes[itemType]) {
                    errors.push(
                      `Line ${i + 1}: Unexpected output type '${itemType}'. Expected one of: ${Object.keys(expectedOutputTypes).join(", ")}`
                    );
                    continue;
                  }
                  // Check for too many items of the same type
                  const typeCount = parsedItems.filter(
                    existing => existing.type === itemType
                  ).length;
                  const maxAllowed = getMaxAllowedForType(itemType, expectedOutputTypes);
                  if (typeCount >= maxAllowed) {
                    errors.push(
                      `Line ${i + 1}: Too many items of type '${itemType}'. Maximum allowed: ${maxAllowed}.`
                    );
                    continue;
                  }
                  // Basic validation based on type
                  switch (itemType) {
                    case "create-issue":
                      if (!item.title || typeof item.title !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-issue requires a 'title' string field`
                        );
                        continue;
                      }
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-issue requires a 'body' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.title = sanitizeContent(item.title);
                      item.body = sanitizeContent(item.body);
                      // Sanitize labels if present
                      if (item.labels && Array.isArray(item.labels)) {
                        item.labels = item.labels.map(
                          /** @param {any} label */ label =>
                            typeof label === "string" ? sanitizeContent(label) : label
                        );
                      }
                      break;
                    case "add-issue-comment":
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: add-issue-comment requires a 'body' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.body = sanitizeContent(item.body);
                      break;
                    case "create-pull-request":
                      if (!item.title || typeof item.title !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-pull-request requires a 'title' string field`
                        );
                        continue;
                      }
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-pull-request requires a 'body' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.title = sanitizeContent(item.title);
                      item.body = sanitizeContent(item.body);
                      // Sanitize branch name if present
                      if (item.branch && typeof item.branch === "string") {
                        item.branch = sanitizeContent(item.branch);
                      }
                      // Sanitize labels if present
                      if (item.labels && Array.isArray(item.labels)) {
                        item.labels = item.labels.map(
                          /** @param {any} label */ label =>
                            typeof label === "string" ? sanitizeContent(label) : label
                        );
                      }
                      break;
                    case "add-issue-label":
                      if (!item.labels || !Array.isArray(item.labels)) {
                        errors.push(
                          `Line ${i + 1}: add-issue-label requires a 'labels' array field`
                        );
                        continue;
                      }
                      if (
                        item.labels.some(
                          /** @param {any} label */ label => typeof label !== "string"
                        )
                      ) {
                        errors.push(
                          `Line ${i + 1}: add-issue-label labels array must contain only strings`
                        );
                        continue;
                      }
                      // Sanitize label strings
                      item.labels = item.labels.map(
                        /** @param {any} label */ label => sanitizeContent(label)
                      );
                      break;
                    case "update-issue":
                      // Check that at least one updateable field is provided
                      const hasValidField =
                        item.status !== undefined ||
                        item.title !== undefined ||
                        item.body !== undefined;
                      if (!hasValidField) {
                        errors.push(
                          `Line ${i + 1}: update-issue requires at least one of: 'status', 'title', or 'body' fields`
                        );
                        continue;
                      }
                      // Validate status if provided
                      if (item.status !== undefined) {
                        if (
                          typeof item.status !== "string" ||
                          (item.status !== "open" && item.status !== "closed")
                        ) {
                          errors.push(
                            `Line ${i + 1}: update-issue 'status' must be 'open' or 'closed'`
                          );
                          continue;
                        }
                      }
                      // Validate title if provided
                      if (item.title !== undefined) {
                        if (typeof item.title !== "string") {
                          errors.push(
                            `Line ${i + 1}: update-issue 'title' must be a string`
                          );
                          continue;
                        }
                        item.title = sanitizeContent(item.title);
                      }
                      // Validate body if provided
                      if (item.body !== undefined) {
                        if (typeof item.body !== "string") {
                          errors.push(
                            `Line ${i + 1}: update-issue 'body' must be a string`
                          );
                          continue;
                        }
                        item.body = sanitizeContent(item.body);
                      }
                      // Validate issue_number if provided (for target "*")
                      if (item.issue_number !== undefined) {
                        if (
                          typeof item.issue_number !== "number" &&
                          typeof item.issue_number !== "string"
                        ) {
                          errors.push(
                            `Line ${i + 1}: update-issue 'issue_number' must be a number or string`
                          );
                          continue;
                        }
                      }
                      break;
                    case "push-to-pr-branch":
                      // Validate message if provided (optional)
                      if (item.message !== undefined) {
                        if (typeof item.message !== "string") {
                          errors.push(
                            `Line ${i + 1}: push-to-pr-branch 'message' must be a string`
                          );
                          continue;
                        }
                        item.message = sanitizeContent(item.message);
                      }
                      // Validate pull_request_number if provided (for target "*")
                      if (item.pull_request_number !== undefined) {
                        if (
                          typeof item.pull_request_number !== "number" &&
                          typeof item.pull_request_number !== "string"
                        ) {
                          errors.push(
                            `Line ${i + 1}: push-to-pr-branch 'pull_request_number' must be a number or string`
                          );
                          continue;
                        }
                      }
                      break;
                    case "create-pull-request-review-comment":
                      // Validate required path field
                      if (!item.path || typeof item.path !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-pull-request-review-comment requires a 'path' string field`
                        );
                        continue;
                      }
                      // Validate required line field
                      if (
                        item.line === undefined ||
                        (typeof item.line !== "number" && typeof item.line !== "string")
                      ) {
                        errors.push(
                          `Line ${i + 1}: create-pull-request-review-comment requires a 'line' number or string field`
                        );
                        continue;
                      }
                      // Validate line is a positive integer
                      const lineNumber =
                        typeof item.line === "string" ? parseInt(item.line, 10) : item.line;
                      if (
                        isNaN(lineNumber) ||
                        lineNumber <= 0 ||
                        !Number.isInteger(lineNumber)
                      ) {
                        errors.push(
                          `Line ${i + 1}: create-pull-request-review-comment 'line' must be a positive integer`
                        );
                        continue;
                      }
                      // Validate required body field
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-pull-request-review-comment requires a 'body' string field`
                        );
                        continue;
                      }
                      // Sanitize required text content
                      item.body = sanitizeContent(item.body);
                      // Validate optional start_line field
                      if (item.start_line !== undefined) {
                        if (
                          typeof item.start_line !== "number" &&
                          typeof item.start_line !== "string"
                        ) {
                          errors.push(
                            `Line ${i + 1}: create-pull-request-review-comment 'start_line' must be a number or string`
                          );
                          continue;
                        }
                        const startLineNumber =
                          typeof item.start_line === "string"
                            ? parseInt(item.start_line, 10)
                            : item.start_line;
                        if (
                          isNaN(startLineNumber) ||
                          startLineNumber <= 0 ||
                          !Number.isInteger(startLineNumber)
                        ) {
                          errors.push(
                            `Line ${i + 1}: create-pull-request-review-comment 'start_line' must be a positive integer`
                          );
                          continue;
                        }
                        if (startLineNumber > lineNumber) {
                          errors.push(
                            `Line ${i + 1}: create-pull-request-review-comment 'start_line' must be less than or equal to 'line'`
                          );
                          continue;
                        }
                      }
                      // Validate optional side field
                      if (item.side !== undefined) {
                        if (
                          typeof item.side !== "string" ||
                          (item.side !== "LEFT" && item.side !== "RIGHT")
                        ) {
                          errors.push(
                            `Line ${i + 1}: create-pull-request-review-comment 'side' must be 'LEFT' or 'RIGHT'`
                          );
                          continue;
                        }
                      }
                      break;
                    case "create-discussion":
                      if (!item.title || typeof item.title !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-discussion requires a 'title' string field`
                        );
                        continue;
                      }
                      if (!item.body || typeof item.body !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-discussion requires a 'body' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.title = sanitizeContent(item.title);
                      item.body = sanitizeContent(item.body);
                      break;
                    case "missing-tool":
                      // Validate required tool field
                      if (!item.tool || typeof item.tool !== "string") {
                        errors.push(
                          `Line ${i + 1}: missing-tool requires a 'tool' string field`
                        );
                        continue;
                      }
                      // Validate required reason field
                      if (!item.reason || typeof item.reason !== "string") {
                        errors.push(
                          `Line ${i + 1}: missing-tool requires a 'reason' string field`
                        );
                        continue;
                      }
                      // Sanitize text content
                      item.tool = sanitizeContent(item.tool);
                      item.reason = sanitizeContent(item.reason);
                      // Validate optional alternatives field
                      if (item.alternatives !== undefined) {
                        if (typeof item.alternatives !== "string") {
                          errors.push(
                            `Line ${i + 1}: missing-tool 'alternatives' must be a string`
                          );
                          continue;
                        }
                        item.alternatives = sanitizeContent(item.alternatives);
                      }
                      break;
                    case "create-code-scanning-alert":
                      // Validate required fields
                      if (!item.file || typeof item.file !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert requires a 'file' field (string)`
                        );
                        continue;
                      }
                      if (
                        item.line === undefined ||
                        item.line === null ||
                        (typeof item.line !== "number" && typeof item.line !== "string")
                      ) {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert requires a 'line' field (number or string)`
                        );
                        continue;
                      }
                      // Additional validation: line must be parseable as a positive integer
                      const parsedLine = parseInt(item.line, 10);
                      if (isNaN(parsedLine) || parsedLine <= 0) {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert 'line' must be a valid positive integer (got: ${item.line})`
                        );
                        continue;
                      }
                      if (!item.severity || typeof item.severity !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert requires a 'severity' field (string)`
                        );
                        continue;
                      }
                      if (!item.message || typeof item.message !== "string") {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert requires a 'message' field (string)`
                        );
                        continue;
                      }
                      // Validate severity level
                      const allowedSeverities = ["error", "warning", "info", "note"];
                      if (!allowedSeverities.includes(item.severity.toLowerCase())) {
                        errors.push(
                          `Line ${i + 1}: create-code-scanning-alert 'severity' must be one of: ${allowedSeverities.join(", ")}`
                        );
                        continue;
                      }
                      // Validate optional column field
                      if (item.column !== undefined) {
                        if (
                          typeof item.column !== "number" &&
                          typeof item.column !== "string"
                        ) {
                          errors.push(
                            `Line ${i + 1}: create-code-scanning-alert 'column' must be a number or string`
                          );
                          continue;
                        }
                        // Additional validation: must be parseable as a positive integer
                        const parsedColumn = parseInt(item.column, 10);
                        if (isNaN(parsedColumn) || parsedColumn <= 0) {
                          errors.push(
                            `Line ${i + 1}: create-code-scanning-alert 'column' must be a valid positive integer (got: ${item.column})`
                          );
                          continue;
                        }
                      }
                      // Validate optional ruleIdSuffix field
                      if (item.ruleIdSuffix !== undefined) {
                        if (typeof item.ruleIdSuffix !== "string") {
                          errors.push(
                            `Line ${i + 1}: create-code-scanning-alert 'ruleIdSuffix' must be a string`
                          );
                          continue;
                        }
                        if (!/^[a-zA-Z0-9_-]+$/.test(item.ruleIdSuffix.trim())) {
                          errors.push(
                            `Line ${i + 1}: create-code-scanning-alert 'ruleIdSuffix' must contain only alphanumeric characters, hyphens, and underscores`
                          );
                          continue;
                        }
                      }
                      // Normalize severity to lowercase and sanitize string fields
                      item.severity = item.severity.toLowerCase();
                      item.file = sanitizeContent(item.file);
                      item.severity = sanitizeContent(item.severity);
                      item.message = sanitizeContent(item.message);
                      if (item.ruleIdSuffix) {
                        item.ruleIdSuffix = sanitizeContent(item.ruleIdSuffix);
                      }
                      break;
                    default:
                      errors.push(`Line ${i + 1}: Unknown output type '${itemType}'`);
                      continue;
                  }
                  core.info(`Line ${i + 1}: Valid ${itemType} item`);
                  parsedItems.push(item);
                } catch (error) {
                  const errorMsg = error instanceof Error ? error.message : String(error);
                  errors.push(`Line ${i + 1}: Invalid JSON - ${errorMsg}`);
                }
              }
              // Report validation results
              if (errors.length > 0) {
                core.warning("Validation errors found:");
                errors.forEach(error => core.warning(`  - ${error}`));
                if (parsedItems.length === 0) {
                  core.setFailed(errors.map(e => `  - ${e}`).join("\n"));
                  return;
                }
                // For now, we'll continue with valid items but log the errors
                // In the future, we might want to fail the workflow for invalid items
              }
              core.info(`Successfully parsed ${parsedItems.length} valid output items`);
              // Set the parsed and validated items as output
              const validatedOutput = {
                items: parsedItems,
                errors: errors,
              };
              // Store validatedOutput JSON in "agent_output.json" file
              const agentOutputFile = "/tmp/agent_output.json";
              const validatedOutputJson = JSON.stringify(validatedOutput);
              try {
                // Ensure the /tmp directory exists
                fs.mkdirSync("/tmp", { recursive: true });
                fs.writeFileSync(agentOutputFile, validatedOutputJson, "utf8");
                core.info(`Stored validated output to: ${agentOutputFile}`);
                // Set the environment variable GITHUB_AW_AGENT_OUTPUT to the file path
                core.exportVariable("GITHUB_AW_AGENT_OUTPUT", agentOutputFile);
              } catch (error) {
                const errorMsg = error instanceof Error ? error.message : String(error);
                core.error(`Failed to write agent output file: ${errorMsg}`);
              }
              core.setOutput("output", JSON.stringify(validatedOutput));
              core.setOutput("raw_output", outputContent);
            }
            // Call the main function
            await main();
      - name: Print sanitized agent output
        run: |
          echo "## Processed Output" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````json' >> $GITHUB_STEP_SUMMARY
          echo '${{ steps.collect_output.outputs.output }}' >> $GITHUB_STEP_SUMMARY
          echo '``````' >> $GITHUB_STEP_SUMMARY
      - name: Upload sanitized agent output
        if: always() && env.GITHUB_AW_AGENT_OUTPUT
        uses: actions/upload-artifact@v4
        with:
          name: agent_output.json
          path: ${{ env.GITHUB_AW_AGENT_OUTPUT }}
          if-no-files-found: warn
      - name: Upload agent logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-safe-outputs-custom-engine.log
          path: /tmp/test-safe-outputs-custom-engine.log
          if-no-files-found: warn
      - name: Generate git patch
        if: always()
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
        run: |
          # Check current git status
          echo "Current git status:"
          git status
          
          # Extract branch name from JSONL output
          BRANCH_NAME=""
          if [ -f "$GITHUB_AW_SAFE_OUTPUTS" ]; then
            echo "Checking for branch name in JSONL output..."
            while IFS= read -r line; do
              if [ -n "$line" ]; then
                # Extract branch from create-pull-request line using simple grep and sed
                if echo "$line" | grep -q '"type"[[:space:]]*:[[:space:]]*"create-pull-request"'; then
                  echo "Found create-pull-request line: $line"
                  # Extract branch value using sed
                  BRANCH_NAME=$(echo "$line" | sed -n 's/.*"branch"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
                  if [ -n "$BRANCH_NAME" ]; then
                    echo "Extracted branch name from create-pull-request: $BRANCH_NAME"
                    break
                  fi
                # Extract branch from push-to-pr-branch line using simple grep and sed
                elif echo "$line" | grep -q '"type"[[:space:]]*:[[:space:]]*"push-to-pr-branch"'; then
                  echo "Found push-to-pr-branch line: $line"
                  # Extract branch value using sed
                  BRANCH_NAME=$(echo "$line" | sed -n 's/.*"branch"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')
                  if [ -n "$BRANCH_NAME" ]; then
                    echo "Extracted branch name from create-pull-request: $BRANCH_NAME"
                    break
                  fi
                fi
              fi
            done < "$GITHUB_AW_SAFE_OUTPUTS"
          fi
          
          # Get the initial commit SHA from the base branch of the pull request
          if [ "$GITHUB_EVENT_NAME" = "pull_request" ] || [ "$GITHUB_EVENT_NAME" = "pull_request_review_comment" ]; then
            INITIAL_SHA="$GITHUB_BASE_REF"
          else
            INITIAL_SHA="$GITHUB_SHA"
          fi
          echo "Base commit SHA: $INITIAL_SHA"
          
          # If we have a branch name, check if that branch exists and get its diff
          if [ -n "$BRANCH_NAME" ]; then
            echo "Looking for branch: $BRANCH_NAME"
            # Check if the branch exists
            if git show-ref --verify --quiet refs/heads/$BRANCH_NAME; then
              echo "Branch $BRANCH_NAME exists, generating patch from branch changes"
              # Generate patch from the base to the branch
              git format-patch "$INITIAL_SHA".."$BRANCH_NAME" --stdout > /tmp/aw.patch || echo "Failed to generate patch from branch" > /tmp/aw.patch
              echo "Patch file created from branch: $BRANCH_NAME"
            else
              echo "Branch $BRANCH_NAME does not exist, falling back to current HEAD"
              BRANCH_NAME=""
            fi
          fi
          
          # If no branch or branch doesn't exist, use the existing logic
          if [ -z "$BRANCH_NAME" ]; then
            echo "Using current HEAD for patch generation"
            # Stage any unstaged files
            git add -A || true
            # Check if there are staged files to commit
            if ! git diff --cached --quiet; then
              echo "Staged files found, committing them..."
              git commit -m "[agent] staged files" || true
              echo "Staged files committed"
            else
              echo "No staged files to commit"
            fi
            # Check updated git status
            echo "Updated git status after committing staged files:"
            git status
            # Show compact diff information between initial commit and HEAD (committed changes only)
            echo '## Git diff' >> $GITHUB_STEP_SUMMARY
            echo '' >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            git diff --name-only "$INITIAL_SHA"..HEAD >> $GITHUB_STEP_SUMMARY || true
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo '' >> $GITHUB_STEP_SUMMARY
            # Check if there are any committed changes since the initial commit
            if git diff --quiet "$INITIAL_SHA" HEAD; then
              echo "No committed changes detected since initial commit"
              echo "Skipping patch generation - no committed changes to create patch from"
            else
              echo "Committed changes detected, generating patch..."
              # Generate patch from initial commit to HEAD (committed changes only)
              git format-patch "$INITIAL_SHA"..HEAD --stdout > /tmp/aw.patch || echo "Failed to generate patch" > /tmp/aw.patch
              echo "Patch file created at /tmp/aw.patch"
            fi
          fi
          
          # Show patch info if it exists
          if [ -f /tmp/aw.patch ]; then
            ls -la /tmp/aw.patch
            # Show the first 50 lines of the patch for review
            echo '## Git Patch' >> $GITHUB_STEP_SUMMARY
            echo '' >> $GITHUB_STEP_SUMMARY
            echo '```diff' >> $GITHUB_STEP_SUMMARY
            head -500 /tmp/aw.patch >> $GITHUB_STEP_SUMMARY || echo "Could not display patch contents" >> $GITHUB_STEP_SUMMARY
            echo '...' >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo '' >> $GITHUB_STEP_SUMMARY
          fi
      - name: Upload git patch
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: aw.patch
          path: /tmp/aw.patch
          if-no-files-found: ignore

  create_issue:
    needs: test-safe-outputs-custom-engine
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    timeout-minutes: 10
    outputs:
      issue_number: ${{ steps.create_issue.outputs.issue_number }}
      issue_url: ${{ steps.create_issue.outputs.issue_url }}
    steps:
      - name: Check team membership for workflow
        id: check-team-member
        uses: actions/github-script@v7
        env:
          GITHUB_AW_REQUIRED_ROLES: admin,maintainer
        with:
          script: |
            async function setCancelled(message) {
              try {
                await github.rest.actions.cancelWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: context.runId,
                });
                core.info(`Cancellation requested for this workflow run: ${message}`);
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                core.warning(`Failed to cancel workflow run: ${errorMessage}`);
                core.setFailed(message); // Fallback if API call fails
              }
            }
            async function main() {
              const { eventName } = context;
              // skip check for safe events
              const safeEvents = ["workflow_dispatch", "workflow_run", "schedule"];
              if (safeEvents.includes(eventName)) {
                core.info(`✅ Event ${eventName} does not require validation`);
                return;
              }
              const actor = context.actor;
              const { owner, repo } = context.repo;
              const requiredPermissionsEnv = process.env.GITHUB_AW_REQUIRED_ROLES;
              const requiredPermissions = requiredPermissionsEnv
                ? requiredPermissionsEnv.split(",").filter(p => p.trim() !== "")
                : [];
              if (!requiredPermissions || requiredPermissions.length === 0) {
                core.error(
                  "❌ Configuration error: Required permissions not specified. Contact repository administrator."
                );
                await setCancelled(
                  "Configuration error: Required permissions not specified"
                );
                return;
              }
              // Check if the actor has the required repository permissions
              try {
                core.debug(
                  `Checking if user '${actor}' has required permissions for ${owner}/${repo}`
                );
                core.debug(`Required permissions: ${requiredPermissions.join(", ")}`);
                const repoPermission =
                  await github.rest.repos.getCollaboratorPermissionLevel({
                    owner: owner,
                    repo: repo,
                    username: actor,
                  });
                const permission = repoPermission.data.permission;
                core.debug(`Repository permission level: ${permission}`);
                // Check if user has one of the required permission levels
                for (const requiredPerm of requiredPermissions) {
                  if (
                    permission === requiredPerm ||
                    (requiredPerm === "maintainer" && permission === "maintain")
                  ) {
                    core.info(`✅ User has ${permission} access to repository`);
                    return;
                  }
                }
                core.warning(
                  `User permission '${permission}' does not meet requirements: ${requiredPermissions.join(", ")}`
                );
              } catch (repoError) {
                const errorMessage =
                  repoError instanceof Error ? repoError.message : String(repoError);
                core.error(`Repository permission check failed: ${errorMessage}`);
                await setCancelled(`Repository permission check failed: ${errorMessage}`);
                return;
              }
              // Cancel the workflow when permission check fails
              core.warning(
                `❌ Access denied: Only authorized users can trigger this workflow. User '${actor}' is not authorized. Required permissions: ${requiredPermissions.join(", ")}`
              );
              await setCancelled(
                `Access denied: User '${actor}' is not authorized. Required permissions: ${requiredPermissions.join(", ")}`
              );
            }
            await main();
      - name: Create Output Issue
        id: create_issue
        uses: actions/github-script@v7
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.test-safe-outputs-custom-engine.outputs.output }}
          GITHUB_AW_ISSUE_TITLE_PREFIX: "[Custom Engine Test] "
          GITHUB_AW_ISSUE_LABELS: "test-safe-outputs,automation,custom-engine"
        with:
          script: |
            async function main() {
              // Check if we're in staged mode
              const isStaged = process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true";
              // Read the validated output content from environment variable
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT;
              if (!outputContent) {
                core.info("No GITHUB_AW_AGENT_OUTPUT environment variable found");
                return;
              }
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
                return;
              }
              core.info(`Agent output content length: ${outputContent.length}`);
              // Parse the validated output JSON
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(
                  `Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`
                );
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.info("No valid items found in agent output");
                return;
              }
              // Find all create-issue items
              const createIssueItems = validatedOutput.items.filter(
                /** @param {any} item */ item => item.type === "create-issue"
              );
              if (createIssueItems.length === 0) {
                core.info("No create-issue items found in agent output");
                return;
              }
              core.info(`Found ${createIssueItems.length} create-issue item(s)`);
              // If in staged mode, emit step summary instead of creating issues
              if (isStaged) {
                let summaryContent = "## 🎭 Staged Mode: Create Issues Preview\n\n";
                summaryContent +=
                  "The following issues would be created if staged mode was disabled:\n\n";
                for (let i = 0; i < createIssueItems.length; i++) {
                  const item = createIssueItems[i];
                  summaryContent += `### Issue ${i + 1}\n`;
                  summaryContent += `**Title:** ${item.title || "No title provided"}\n\n`;
                  if (item.body) {
                    summaryContent += `**Body:**\n${item.body}\n\n`;
                  }
                  if (item.labels && item.labels.length > 0) {
                    summaryContent += `**Labels:** ${item.labels.join(", ")}\n\n`;
                  }
                  summaryContent += "---\n\n";
                }
                // Write to step summary
                await core.summary.addRaw(summaryContent).write();
                core.info("📝 Issue creation preview written to step summary");
                return;
              }
              // Check if we're in an issue context (triggered by an issue event)
              const parentIssueNumber = context.payload?.issue?.number;
              // Parse labels from environment variable (comma-separated string)
              const labelsEnv = process.env.GITHUB_AW_ISSUE_LABELS;
              let envLabels = labelsEnv
                ? labelsEnv
                    .split(",")
                    .map(/** @param {string} label */ label => label.trim())
                    .filter(/** @param {string} label */ label => label)
                : [];
              const createdIssues = [];
              // Process each create-issue item
              for (let i = 0; i < createIssueItems.length; i++) {
                const createIssueItem = createIssueItems[i];
                core.info(
                  `Processing create-issue item ${i + 1}/${createIssueItems.length}: title=${createIssueItem.title}, bodyLength=${createIssueItem.body.length}`
                );
                // Merge environment labels with item-specific labels
                let labels = [...envLabels];
                if (createIssueItem.labels && Array.isArray(createIssueItem.labels)) {
                  labels = [...labels, ...createIssueItem.labels].filter(Boolean);
                }
                // Extract title and body from the JSON item
                let title = createIssueItem.title ? createIssueItem.title.trim() : "";
                let bodyLines = createIssueItem.body.split("\n");
                // If no title was found, use the body content as title (or a default)
                if (!title) {
                  title = createIssueItem.body || "Agent Output";
                }
                // Apply title prefix if provided via environment variable
                const titlePrefix = process.env.GITHUB_AW_ISSUE_TITLE_PREFIX;
                if (titlePrefix && !title.startsWith(titlePrefix)) {
                  title = titlePrefix + title;
                }
                if (parentIssueNumber) {
                  core.info("Detected issue context, parent issue #" + parentIssueNumber);
                  // Add reference to parent issue in the child issue body
                  bodyLines.push(`Related to #${parentIssueNumber}`);
                }
                // Add AI disclaimer with run id, run htmlurl
                // Add AI disclaimer with workflow run information
                const runId = context.runId;
                const runUrl = context.payload.repository
                  ? `${context.payload.repository.html_url}/actions/runs/${runId}`
                  : `https://github.com/actions/runs/${runId}`;
                bodyLines.push(
                  ``,
                  ``,
                  `> Generated by Agentic Workflow [Run](${runUrl})`,
                  ""
                );
                // Prepare the body content
                const body = bodyLines.join("\n").trim();
                core.info(`Creating issue with title: ${title}`);
                core.info(`Labels: ${labels}`);
                core.info(`Body length: ${body.length}`);
                try {
                  // Create the issue using GitHub API
                  const { data: issue } = await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: title,
                    body: body,
                    labels: labels,
                  });
                  core.info("Created issue #" + issue.number + ": " + issue.html_url);
                  createdIssues.push(issue);
                  // If we have a parent issue, add a comment to it referencing the new child issue
                  if (parentIssueNumber) {
                    try {
                      await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: parentIssueNumber,
                        body: `Created related issue: #${issue.number}`,
                      });
                      core.info("Added comment to parent issue #" + parentIssueNumber);
                    } catch (error) {
                      core.info(
                        `Warning: Could not add comment to parent issue: ${error instanceof Error ? error.message : String(error)}`
                      );
                    }
                  }
                  // Set output for the last created issue (for backward compatibility)
                  if (i === createIssueItems.length - 1) {
                    core.setOutput("issue_number", issue.number);
                    core.setOutput("issue_url", issue.html_url);
                  }
                } catch (error) {
                  const errorMessage =
                    error instanceof Error ? error.message : String(error);
                  // Special handling for disabled issues repository
                  if (
                    errorMessage.includes("Issues has been disabled in this repository")
                  ) {
                    core.info(
                      `⚠ Cannot create issue "${title}": Issues are disabled for this repository`
                    );
                    core.info(
                      "Consider enabling issues in repository settings if you want to create issues automatically"
                    );
                    continue; // Skip this issue but continue processing others
                  }
                  core.error(`✗ Failed to create issue "${title}": ${errorMessage}`);
                  throw error;
                }
              }
              // Write summary for all created issues
              if (createdIssues.length > 0) {
                let summaryContent = "\n\n## GitHub Issues\n";
                for (const issue of createdIssues) {
                  summaryContent += `- Issue #${issue.number}: [${issue.title}](${issue.html_url})\n`;
                }
                await core.summary.addRaw(summaryContent).write();
              }
              core.info(`Successfully created ${createdIssues.length} issue(s)`);
            }
            await main();

  create_discussion:
    needs: test-safe-outputs-custom-engine
    runs-on: ubuntu-latest
    permissions:
      contents: read
      discussions: write
    timeout-minutes: 10
    outputs:
      discussion_number: ${{ steps.create_discussion.outputs.discussion_number }}
      discussion_url: ${{ steps.create_discussion.outputs.discussion_url }}
    steps:
      - name: Create Output Discussion
        id: create_discussion
        uses: actions/github-script@v7
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.test-safe-outputs-custom-engine.outputs.output }}
          GITHUB_AW_DISCUSSION_TITLE_PREFIX: "[Custom Engine Test] "
        with:
          script: |
            async function main() {
              // Read the validated output content from environment variable
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT;
              if (!outputContent) {
                core.info("No GITHUB_AW_AGENT_OUTPUT environment variable found");
                return;
              }
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
                return;
              }
              core.debug(`Agent output content length: ${outputContent.length}`);
              // Parse the validated output JSON
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(
                  `Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`
                );
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.warning("No valid items found in agent output");
                return;
              }
              // Find all create-discussion items
              const createDiscussionItems = validatedOutput.items.filter(
                /** @param {any} item */ item => item.type === "create-discussion"
              );
              if (createDiscussionItems.length === 0) {
                core.warning("No create-discussion items found in agent output");
                return;
              }
              core.debug(`Found ${createDiscussionItems.length} create-discussion item(s)`);
              // If in staged mode, emit step summary instead of creating discussions
              if (process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true") {
                let summaryContent = "## 🎭 Staged Mode: Create Discussions Preview\n\n";
                summaryContent +=
                  "The following discussions would be created if staged mode was disabled:\n\n";
                for (let i = 0; i < createDiscussionItems.length; i++) {
                  const item = createDiscussionItems[i];
                  summaryContent += `### Discussion ${i + 1}\n`;
                  summaryContent += `**Title:** ${item.title || "No title provided"}\n\n`;
                  if (item.body) {
                    summaryContent += `**Body:**\n${item.body}\n\n`;
                  }
                  if (item.category_id) {
                    summaryContent += `**Category ID:** ${item.category_id}\n\n`;
                  }
                  summaryContent += "---\n\n";
                }
                // Write to step summary
                await core.summary.addRaw(summaryContent).write();
                core.info("📝 Discussion creation preview written to step summary");
                return;
              }
              // Get repository ID and discussion categories using GraphQL API
              let discussionCategories = [];
              let repositoryId = null;
              try {
                const repositoryQuery = `
                  query($owner: String!, $repo: String!) {
                    repository(owner: $owner, name: $repo) {
                      id
                      discussionCategories(first: 20) {
                        nodes {
                          id
                          name
                          slug
                          description
                        }
                      }
                    }
                  }
                `;
                const queryResult = await github.graphql(repositoryQuery, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                });
                repositoryId = queryResult.repository.id;
                discussionCategories =
                  queryResult.repository.discussionCategories.nodes || [];
                core.info(
                  `Available categories: ${JSON.stringify(
                    discussionCategories.map(
                      /** @param {any} cat */ cat => ({ name: cat.name, id: cat.id })
                    )
                  )}`
                );
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                // Special handling for repositories without discussions enabled or GraphQL errors
                if (
                  errorMessage.includes("Not Found") ||
                  errorMessage.includes("not found") ||
                  errorMessage.includes("Could not resolve to a Repository")
                ) {
                  core.info(
                    "⚠ Cannot create discussions: Discussions are not enabled for this repository"
                  );
                  core.info(
                    "Consider enabling discussions in repository settings if you want to create discussions automatically"
                  );
                  return; // Exit gracefully without creating discussions
                }
                core.error(`Failed to get discussion categories: ${errorMessage}`);
                throw error;
              }
              // Determine category ID
              let categoryId = process.env.GITHUB_AW_DISCUSSION_CATEGORY_ID;
              if (!categoryId && discussionCategories.length > 0) {
                // Default to the first category if none specified
                categoryId = discussionCategories[0].id;
                core.info(
                  `No category-id specified, using default category: ${discussionCategories[0].name} (${categoryId})`
                );
              }
              if (!categoryId) {
                core.error(
                  "No discussion category available and none specified in configuration"
                );
                throw new Error("Discussion category is required but not available");
              }
              if (!repositoryId) {
                core.error("Repository ID is required for creating discussions");
                throw new Error("Repository ID is required but not available");
              }
              const createdDiscussions = [];
              // Process each create-discussion item
              for (let i = 0; i < createDiscussionItems.length; i++) {
                const createDiscussionItem = createDiscussionItems[i];
                core.info(
                  `Processing create-discussion item ${i + 1}/${createDiscussionItems.length}: title=${createDiscussionItem.title}, bodyLength=${createDiscussionItem.body.length}`
                );
                // Extract title and body from the JSON item
                let title = createDiscussionItem.title
                  ? createDiscussionItem.title.trim()
                  : "";
                let bodyLines = createDiscussionItem.body.split("\n");
                // If no title was found, use the body content as title (or a default)
                if (!title) {
                  title = createDiscussionItem.body || "Agent Output";
                }
                // Apply title prefix if provided via environment variable
                const titlePrefix = process.env.GITHUB_AW_DISCUSSION_TITLE_PREFIX;
                if (titlePrefix && !title.startsWith(titlePrefix)) {
                  title = titlePrefix + title;
                }
                // Add AI disclaimer with workflow run information
                const runId = context.runId;
                const runUrl = context.payload.repository
                  ? `${context.payload.repository.html_url}/actions/runs/${runId}`
                  : `https://github.com/actions/runs/${runId}`;
                bodyLines.push(
                  ``,
                  ``,
                  `> Generated by Agentic Workflow [Run](${runUrl})`,
                  ""
                );
                // Prepare the body content
                const body = bodyLines.join("\n").trim();
                core.info(`Creating discussion with title: ${title}`);
                core.info(`Category ID: ${categoryId}`);
                core.info(`Body length: ${body.length}`);
                try {
                  // Create the discussion using GraphQL API with parameterized mutation
                  const createDiscussionMutation = `
                    mutation($repositoryId: ID!, $categoryId: ID!, $title: String!, $body: String!) {
                      createDiscussion(input: {
                        repositoryId: $repositoryId,
                        categoryId: $categoryId,
                        title: $title,
                        body: $body
                      }) {
                        discussion {
                          id
                          number
                          title
                          url
                        }
                      }
                    }
                  `;
                  const mutationResult = await github.graphql(createDiscussionMutation, {
                    repositoryId: repositoryId,
                    categoryId: categoryId,
                    title: title,
                    body: body,
                  });
                  const discussion = mutationResult.createDiscussion.discussion;
                  core.info(
                    "Created discussion #" + discussion.number + ": " + discussion.url
                  );
                  createdDiscussions.push(discussion);
                  // Set output for the last created discussion (for backward compatibility)
                  if (i === createDiscussionItems.length - 1) {
                    core.setOutput("discussion_number", discussion.number);
                    core.setOutput("discussion_url", discussion.url);
                  }
                } catch (error) {
                  core.error(
                    `✗ Failed to create discussion "${title}": ${error instanceof Error ? error.message : String(error)}`
                  );
                  throw error;
                }
              }
              // Write summary for all created discussions
              if (createdDiscussions.length > 0) {
                let summaryContent = "\n\n## GitHub Discussions\n";
                for (const discussion of createdDiscussions) {
                  summaryContent += `- Discussion #${discussion.number}: [${discussion.title}](${discussion.url})\n`;
                }
                await core.summary.addRaw(summaryContent).write();
              }
              core.info(`Successfully created ${createdDiscussions.length} discussion(s)`);
            }
            await main();

  create_issue_comment:
    needs: test-safe-outputs-custom-engine
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
    timeout-minutes: 10
    outputs:
      comment_id: ${{ steps.create_comment.outputs.comment_id }}
      comment_url: ${{ steps.create_comment.outputs.comment_url }}
    steps:
      - name: Add Issue Comment
        id: create_comment
        uses: actions/github-script@v7
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.test-safe-outputs-custom-engine.outputs.output }}
          GITHUB_AW_COMMENT_TARGET: "*"
        with:
          script: |
            async function main() {
              // Check if we're in staged mode
              const isStaged = process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true";
              // Read the validated output content from environment variable
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT;
              if (!outputContent) {
                core.info("No GITHUB_AW_AGENT_OUTPUT environment variable found");
                return;
              }
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
                return;
              }
              core.info(`Agent output content length: ${outputContent.length}`);
              // Parse the validated output JSON
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(
                  `Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`
                );
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.info("No valid items found in agent output");
                return;
              }
              // Find all add-issue-comment items
              const commentItems = validatedOutput.items.filter(
                /** @param {any} item */ item => item.type === "add-issue-comment"
              );
              if (commentItems.length === 0) {
                core.info("No add-issue-comment items found in agent output");
                return;
              }
              core.info(`Found ${commentItems.length} add-issue-comment item(s)`);
              // If in staged mode, emit step summary instead of creating comments
              if (isStaged) {
                let summaryContent = "## 🎭 Staged Mode: Add Comments Preview\n\n";
                summaryContent +=
                  "The following comments would be added if staged mode was disabled:\n\n";
                for (let i = 0; i < commentItems.length; i++) {
                  const item = commentItems[i];
                  summaryContent += `### Comment ${i + 1}\n`;
                  if (item.issue_number) {
                    summaryContent += `**Target Issue:** #${item.issue_number}\n\n`;
                  } else {
                    summaryContent += `**Target:** Current issue/PR\n\n`;
                  }
                  summaryContent += `**Body:**\n${item.body || "No content provided"}\n\n`;
                  summaryContent += "---\n\n";
                }
                // Write to step summary
                await core.summary.addRaw(summaryContent).write();
                core.info("📝 Comment creation preview written to step summary");
                return;
              }
              // Get the target configuration from environment variable
              const commentTarget = process.env.GITHUB_AW_COMMENT_TARGET || "triggering";
              core.info(`Comment target configuration: ${commentTarget}`);
              // Check if we're in an issue or pull request context
              const isIssueContext =
                context.eventName === "issues" || context.eventName === "issue_comment";
              const isPRContext =
                context.eventName === "pull_request" ||
                context.eventName === "pull_request_review" ||
                context.eventName === "pull_request_review_comment";
              // Validate context based on target configuration
              if (commentTarget === "triggering" && !isIssueContext && !isPRContext) {
                core.info(
                  'Target is "triggering" but not running in issue or pull request context, skipping comment creation'
                );
                return;
              }
              const createdComments = [];
              // Process each comment item
              for (let i = 0; i < commentItems.length; i++) {
                const commentItem = commentItems[i];
                core.info(
                  `Processing add-issue-comment item ${i + 1}/${commentItems.length}: bodyLength=${commentItem.body.length}`
                );
                // Determine the issue/PR number and comment endpoint for this comment
                let issueNumber;
                let commentEndpoint;
                if (commentTarget === "*") {
                  // For target "*", we need an explicit issue number from the comment item
                  if (commentItem.issue_number) {
                    issueNumber = parseInt(commentItem.issue_number, 10);
                    if (isNaN(issueNumber) || issueNumber <= 0) {
                      core.info(
                        `Invalid issue number specified: ${commentItem.issue_number}`
                      );
                      continue;
                    }
                    commentEndpoint = "issues";
                  } else {
                    core.info(
                      'Target is "*" but no issue_number specified in comment item'
                    );
                    continue;
                  }
                } else if (commentTarget && commentTarget !== "triggering") {
                  // Explicit issue number specified in target
                  issueNumber = parseInt(commentTarget, 10);
                  if (isNaN(issueNumber) || issueNumber <= 0) {
                    core.info(
                      `Invalid issue number in target configuration: ${commentTarget}`
                    );
                    continue;
                  }
                  commentEndpoint = "issues";
                } else {
                  // Default behavior: use triggering issue/PR
                  if (isIssueContext) {
                    if (context.payload.issue) {
                      issueNumber = context.payload.issue.number;
                      commentEndpoint = "issues";
                    } else {
                      core.info("Issue context detected but no issue found in payload");
                      continue;
                    }
                  } else if (isPRContext) {
                    if (context.payload.pull_request) {
                      issueNumber = context.payload.pull_request.number;
                      commentEndpoint = "issues"; // PR comments use the issues API endpoint
                    } else {
                      core.info(
                        "Pull request context detected but no pull request found in payload"
                      );
                      continue;
                    }
                  }
                }
                if (!issueNumber) {
                  core.info("Could not determine issue or pull request number");
                  continue;
                }
                // Extract body from the JSON item
                let body = commentItem.body.trim();
                // Add AI disclaimer with run id, run htmlurl
                const runId = context.runId;
                const runUrl = context.payload.repository
                  ? `${context.payload.repository.html_url}/actions/runs/${runId}`
                  : `https://github.com/actions/runs/${runId}`;
                body += `\n\n> Generated by Agentic Workflow [Run](${runUrl})\n`;
                core.info(`Creating comment on ${commentEndpoint} #${issueNumber}`);
                core.info(`Comment content length: ${body.length}`);
                try {
                  // Create the comment using GitHub API
                  const { data: comment } = await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    body: body,
                  });
                  core.info("Created comment #" + comment.id + ": " + comment.html_url);
                  createdComments.push(comment);
                  // Set output for the last created comment (for backward compatibility)
                  if (i === commentItems.length - 1) {
                    core.setOutput("comment_id", comment.id);
                    core.setOutput("comment_url", comment.html_url);
                  }
                } catch (error) {
                  core.error(
                    `✗ Failed to create comment: ${error instanceof Error ? error.message : String(error)}`
                  );
                  throw error;
                }
              }
              // Write summary for all created comments
              if (createdComments.length > 0) {
                let summaryContent = "\n\n## GitHub Comments\n";
                for (const comment of createdComments) {
                  summaryContent += `- Comment #${comment.id}: [View Comment](${comment.html_url})\n`;
                }
                await core.summary.addRaw(summaryContent).write();
              }
              core.info(`Successfully created ${createdComments.length} comment(s)`);
              return createdComments;
            }
            await main();

  create_pr_review_comment:
    needs: test-safe-outputs-custom-engine
    if: (github.event.issue.number && github.event.issue.pull_request) || github.event.pull_request
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    timeout-minutes: 10
    outputs:
      review_comment_id: ${{ steps.create_pr_review_comment.outputs.review_comment_id }}
      review_comment_url: ${{ steps.create_pr_review_comment.outputs.review_comment_url }}
    steps:
      - name: Create PR Review Comment
        id: create_pr_review_comment
        uses: actions/github-script@v7
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.test-safe-outputs-custom-engine.outputs.output }}
          GITHUB_AW_PR_REVIEW_COMMENT_SIDE: "RIGHT"
        with:
          script: |
            async function main() {
              // Read the validated output content from environment variable
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT;
              if (!outputContent) {
                core.info("No GITHUB_AW_AGENT_OUTPUT environment variable found");
                return;
              }
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
                return;
              }
              core.info(`Agent output content length: ${outputContent.length}`);
              // Parse the validated output JSON
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(
                  `Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`
                );
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.info("No valid items found in agent output");
                return;
              }
              // Find all create-pull-request-review-comment items
              const reviewCommentItems = validatedOutput.items.filter(
                /** @param {any} item */ item =>
                  item.type === "create-pull-request-review-comment"
              );
              if (reviewCommentItems.length === 0) {
                core.info(
                  "No create-pull-request-review-comment items found in agent output"
                );
                return;
              }
              core.info(
                `Found ${reviewCommentItems.length} create-pull-request-review-comment item(s)`
              );
              // If in staged mode, emit step summary instead of creating review comments
              if (process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true") {
                let summaryContent =
                  "## 🎭 Staged Mode: Create PR Review Comments Preview\n\n";
                summaryContent +=
                  "The following review comments would be created if staged mode was disabled:\n\n";
                for (let i = 0; i < reviewCommentItems.length; i++) {
                  const item = reviewCommentItems[i];
                  summaryContent += `### Review Comment ${i + 1}\n`;
                  summaryContent += `**File:** ${item.path || "No path provided"}\n\n`;
                  summaryContent += `**Line:** ${item.line || "No line provided"}\n\n`;
                  if (item.start_line) {
                    summaryContent += `**Start Line:** ${item.start_line}\n\n`;
                  }
                  summaryContent += `**Side:** ${item.side || "RIGHT"}\n\n`;
                  summaryContent += `**Body:**\n${item.body || "No content provided"}\n\n`;
                  summaryContent += "---\n\n";
                }
                // Write to step summary
                await core.summary.addRaw(summaryContent).write();
                core.info("📝 PR review comment creation preview written to step summary");
                return;
              }
              // Get the side configuration from environment variable
              const defaultSide = process.env.GITHUB_AW_PR_REVIEW_COMMENT_SIDE || "RIGHT";
              core.info(`Default comment side configuration: ${defaultSide}`);
              // Check if we're in a pull request context, or an issue comment context on a PR
              const isPRContext =
                context.eventName === "pull_request" ||
                context.eventName === "pull_request_review" ||
                context.eventName === "pull_request_review_comment" ||
                (context.eventName === "issue_comment" &&
                  context.payload.issue &&
                  context.payload.issue.pull_request);
              if (!isPRContext) {
                core.info(
                  "Not running in pull request context, skipping review comment creation"
                );
                return;
              }
              let pullRequest = context.payload.pull_request;
              if (!pullRequest) {
                //No, github.event.issue.pull_request does not contain the full pull request data like head.sha. It only includes a minimal object with a url pointing to the pull request API resource.
                //To get full PR details (like head.sha, base.ref, etc.), you need to make an API call using that URL.
                if (context.payload.issue && context.payload.issue.pull_request) {
                  // Fetch full pull request details using the GitHub API
                  const prUrl = context.payload.issue.pull_request.url;
                  try {
                    const { data: fullPR } = await github.request(`GET ${prUrl}`, {
                      headers: {
                        Accept: "application/vnd.github+json",
                      },
                    });
                    pullRequest = fullPR;
                    core.info("Fetched full pull request details from API");
                  } catch (error) {
                    core.info(
                      `Failed to fetch full pull request details: ${error instanceof Error ? error.message : String(error)}`
                    );
                    return;
                  }
                } else {
                  core.info(
                    "Pull request data not found in payload - cannot create review comments"
                  );
                  return;
                }
              }
              // Check if we have the commit SHA needed for creating review comments
              if (!pullRequest || !pullRequest.head || !pullRequest.head.sha) {
                core.info(
                  "Pull request head commit SHA not found in payload - cannot create review comments"
                );
                return;
              }
              const pullRequestNumber = pullRequest.number;
              core.info(`Creating review comments on PR #${pullRequestNumber}`);
              const createdComments = [];
              // Process each review comment item
              for (let i = 0; i < reviewCommentItems.length; i++) {
                const commentItem = reviewCommentItems[i];
                core.info(
                  `Processing create-pull-request-review-comment item ${i + 1}/${reviewCommentItems.length}: bodyLength=${commentItem.body ? commentItem.body.length : "undefined"}, path=${commentItem.path}, line=${commentItem.line}, startLine=${commentItem.start_line}`
                );
                // Validate required fields
                if (!commentItem.path) {
                  core.info('Missing required field "path" in review comment item');
                  continue;
                }
                if (
                  !commentItem.line ||
                  (typeof commentItem.line !== "number" &&
                    typeof commentItem.line !== "string")
                ) {
                  core.info(
                    'Missing or invalid required field "line" in review comment item'
                  );
                  continue;
                }
                if (!commentItem.body || typeof commentItem.body !== "string") {
                  core.info(
                    'Missing or invalid required field "body" in review comment item'
                  );
                  continue;
                }
                // Parse line numbers
                const line = parseInt(commentItem.line, 10);
                if (isNaN(line) || line <= 0) {
                  core.info(`Invalid line number: ${commentItem.line}`);
                  continue;
                }
                let startLine = undefined;
                if (commentItem.start_line) {
                  startLine = parseInt(commentItem.start_line, 10);
                  if (isNaN(startLine) || startLine <= 0 || startLine > line) {
                    core.info(
                      `Invalid start_line number: ${commentItem.start_line} (must be <= line: ${line})`
                    );
                    continue;
                  }
                }
                // Determine side (LEFT or RIGHT)
                const side = commentItem.side || defaultSide;
                if (side !== "LEFT" && side !== "RIGHT") {
                  core.info(`Invalid side value: ${side} (must be LEFT or RIGHT)`);
                  continue;
                }
                // Extract body from the JSON item
                let body = commentItem.body.trim();
                // Add AI disclaimer with run id, run htmlurl
                const runId = context.runId;
                const runUrl = context.payload.repository
                  ? `${context.payload.repository.html_url}/actions/runs/${runId}`
                  : `https://github.com/actions/runs/${runId}`;
                body += `\n\n> Generated by Agentic Workflow [Run](${runUrl})\n`;
                core.info(
                  `Creating review comment on PR #${pullRequestNumber} at ${commentItem.path}:${line}${startLine ? ` (lines ${startLine}-${line})` : ""} [${side}]`
                );
                core.info(`Comment content length: ${body.length}`);
                try {
                  // Prepare the request parameters
                  /** @type {any} */
                  const requestParams = {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pullRequestNumber,
                    body: body,
                    path: commentItem.path,
                    commit_id: pullRequest && pullRequest.head ? pullRequest.head.sha : "", // Required for creating review comments
                    line: line,
                    side: side,
                  };
                  // Add start_line for multi-line comments
                  if (startLine !== undefined) {
                    requestParams.start_line = startLine;
                    requestParams.start_side = side; // start_side should match side for consistency
                  }
                  // Create the review comment using GitHub API
                  const { data: comment } =
                    await github.rest.pulls.createReviewComment(requestParams);
                  core.info(
                    "Created review comment #" + comment.id + ": " + comment.html_url
                  );
                  createdComments.push(comment);
                  // Set output for the last created comment (for backward compatibility)
                  if (i === reviewCommentItems.length - 1) {
                    core.setOutput("review_comment_id", comment.id);
                    core.setOutput("review_comment_url", comment.html_url);
                  }
                } catch (error) {
                  core.error(
                    `✗ Failed to create review comment: ${error instanceof Error ? error.message : String(error)}`
                  );
                  throw error;
                }
              }
              // Write summary for all created comments
              if (createdComments.length > 0) {
                let summaryContent = "\n\n## GitHub PR Review Comments\n";
                for (const comment of createdComments) {
                  summaryContent += `- Review Comment #${comment.id}: [View Comment](${comment.html_url})\n`;
                }
                await core.summary.addRaw(summaryContent).write();
              }
              core.info(`Successfully created ${createdComments.length} review comment(s)`);
              return createdComments;
            }
            await main();

  create_code_scanning_alert:
    needs: test-safe-outputs-custom-engine
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      actions: read
    timeout-minutes: 10
    outputs:
      artifact_uploaded: ${{ steps.create_code_scanning_alert.outputs.artifact_uploaded }}
      codeql_uploaded: ${{ steps.create_code_scanning_alert.outputs.codeql_uploaded }}
      findings_count: ${{ steps.create_code_scanning_alert.outputs.findings_count }}
      sarif_file: ${{ steps.create_code_scanning_alert.outputs.sarif_file }}
    steps:
      - name: Create Code Scanning Alert
        id: create_code_scanning_alert
        uses: actions/github-script@v7
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.test-safe-outputs-custom-engine.outputs.output }}
          GITHUB_AW_SECURITY_REPORT_MAX: 5
          GITHUB_AW_SECURITY_REPORT_DRIVER: Test Safe Outputs - Custom Engine
          GITHUB_AW_WORKFLOW_FILENAME: test-custom-safe-outputs
        with:
          script: |
            async function main() {
              // Read the validated output content from environment variable
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT;
              if (!outputContent) {
                core.info("No GITHUB_AW_AGENT_OUTPUT environment variable found");
                return;
              }
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
                return;
              }
              core.info(`Agent output content length: ${outputContent.length}`);
              // Parse the validated output JSON
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(
                  `Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`
                );
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.info("No valid items found in agent output");
                return;
              }
              // Find all create-code-scanning-alert items
              const securityItems = validatedOutput.items.filter(
                /** @param {any} item */ item => item.type === "create-code-scanning-alert"
              );
              if (securityItems.length === 0) {
                core.info("No create-code-scanning-alert items found in agent output");
                return;
              }
              core.info(`Found ${securityItems.length} create-code-scanning-alert item(s)`);
              // If in staged mode, emit step summary instead of creating code scanning alerts
              if (process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true") {
                let summaryContent =
                  "## 🎭 Staged Mode: Create Code Scanning Alerts Preview\n\n";
                summaryContent +=
                  "The following code scanning alerts would be created if staged mode was disabled:\n\n";
                for (let i = 0; i < securityItems.length; i++) {
                  const item = securityItems[i];
                  summaryContent += `### Security Finding ${i + 1}\n`;
                  summaryContent += `**File:** ${item.file || "No file provided"}\n\n`;
                  summaryContent += `**Line:** ${item.line || "No line provided"}\n\n`;
                  summaryContent += `**Severity:** ${item.severity || "No severity provided"}\n\n`;
                  summaryContent += `**Message:**\n${item.message || "No message provided"}\n\n`;
                  summaryContent += "---\n\n";
                }
                // Write to step summary
                await core.summary.addRaw(summaryContent).write();
                core.info(
                  "📝 Code scanning alert creation preview written to step summary"
                );
                return;
              }
              // Get the max configuration from environment variable
              const maxFindings = process.env.GITHUB_AW_SECURITY_REPORT_MAX
                ? parseInt(process.env.GITHUB_AW_SECURITY_REPORT_MAX)
                : 0; // 0 means unlimited
              core.info(
                `Max findings configuration: ${maxFindings === 0 ? "unlimited" : maxFindings}`
              );
              // Get the driver configuration from environment variable
              const driverName =
                process.env.GITHUB_AW_SECURITY_REPORT_DRIVER ||
                "GitHub Agentic Workflows Security Scanner";
              core.info(`Driver name: ${driverName}`);
              // Get the workflow filename for rule ID prefix
              const workflowFilename =
                process.env.GITHUB_AW_WORKFLOW_FILENAME || "workflow";
              core.info(`Workflow filename for rule ID prefix: ${workflowFilename}`);
              const validFindings = [];
              // Process each security item and validate the findings
              for (let i = 0; i < securityItems.length; i++) {
                const securityItem = securityItems[i];
                core.info(
                  `Processing create-code-scanning-alert item ${i + 1}/${securityItems.length}: file=${securityItem.file}, line=${securityItem.line}, severity=${securityItem.severity}, messageLength=${securityItem.message ? securityItem.message.length : "undefined"}, ruleIdSuffix=${securityItem.ruleIdSuffix || "not specified"}`
                );
                // Validate required fields
                if (!securityItem.file) {
                  core.info('Missing required field "file" in code scanning alert item');
                  continue;
                }
                if (
                  !securityItem.line ||
                  (typeof securityItem.line !== "number" &&
                    typeof securityItem.line !== "string")
                ) {
                  core.info(
                    'Missing or invalid required field "line" in code scanning alert item'
                  );
                  continue;
                }
                if (!securityItem.severity || typeof securityItem.severity !== "string") {
                  core.info(
                    'Missing or invalid required field "severity" in code scanning alert item'
                  );
                  continue;
                }
                if (!securityItem.message || typeof securityItem.message !== "string") {
                  core.info(
                    'Missing or invalid required field "message" in code scanning alert item'
                  );
                  continue;
                }
                // Parse line number
                const line = parseInt(securityItem.line, 10);
                if (isNaN(line) || line <= 0) {
                  core.info(`Invalid line number: ${securityItem.line}`);
                  continue;
                }
                // Parse optional column number
                let column = 1; // Default to column 1
                if (securityItem.column !== undefined) {
                  if (
                    typeof securityItem.column !== "number" &&
                    typeof securityItem.column !== "string"
                  ) {
                    core.info(
                      'Invalid field "column" in code scanning alert item (must be number or string)'
                    );
                    continue;
                  }
                  const parsedColumn = parseInt(securityItem.column, 10);
                  if (isNaN(parsedColumn) || parsedColumn <= 0) {
                    core.info(`Invalid column number: ${securityItem.column}`);
                    continue;
                  }
                  column = parsedColumn;
                }
                // Parse optional rule ID suffix
                let ruleIdSuffix = null;
                if (securityItem.ruleIdSuffix !== undefined) {
                  if (typeof securityItem.ruleIdSuffix !== "string") {
                    core.info(
                      'Invalid field "ruleIdSuffix" in code scanning alert item (must be string)'
                    );
                    continue;
                  }
                  // Validate that the suffix doesn't contain invalid characters
                  const trimmedSuffix = securityItem.ruleIdSuffix.trim();
                  if (trimmedSuffix.length === 0) {
                    core.info(
                      'Invalid field "ruleIdSuffix" in code scanning alert item (cannot be empty)'
                    );
                    continue;
                  }
                  // Check for characters that would be problematic in rule IDs
                  if (!/^[a-zA-Z0-9_-]+$/.test(trimmedSuffix)) {
                    core.info(
                      `Invalid ruleIdSuffix "${trimmedSuffix}" (must contain only alphanumeric characters, hyphens, and underscores)`
                    );
                    continue;
                  }
                  ruleIdSuffix = trimmedSuffix;
                }
                // Validate severity level and map to SARIF level
                /** @type {Record<string, string>} */
                const severityMap = {
                  error: "error",
                  warning: "warning",
                  info: "note",
                  note: "note",
                };
                const normalizedSeverity = securityItem.severity.toLowerCase();
                if (!severityMap[normalizedSeverity]) {
                  core.info(
                    `Invalid severity level: ${securityItem.severity} (must be error, warning, info, or note)`
                  );
                  continue;
                }
                const sarifLevel = severityMap[normalizedSeverity];
                // Create a valid finding object
                validFindings.push({
                  file: securityItem.file.trim(),
                  line: line,
                  column: column,
                  severity: normalizedSeverity,
                  sarifLevel: sarifLevel,
                  message: securityItem.message.trim(),
                  ruleIdSuffix: ruleIdSuffix,
                });
                // Check if we've reached the max limit
                if (maxFindings > 0 && validFindings.length >= maxFindings) {
                  core.info(`Reached maximum findings limit: ${maxFindings}`);
                  break;
                }
              }
              if (validFindings.length === 0) {
                core.info("No valid security findings to report");
                return;
              }
              core.info(`Processing ${validFindings.length} valid security finding(s)`);
              // Generate SARIF file
              const sarifContent = {
                $schema:
                  "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
                version: "2.1.0",
                runs: [
                  {
                    tool: {
                      driver: {
                        name: driverName,
                        version: "1.0.0",
                        informationUri: "https://github.com/githubnext/gh-aw",
                      },
                    },
                    results: validFindings.map((finding, index) => ({
                      ruleId: finding.ruleIdSuffix
                        ? `${workflowFilename}-${finding.ruleIdSuffix}`
                        : `${workflowFilename}-security-finding-${index + 1}`,
                      message: { text: finding.message },
                      level: finding.sarifLevel,
                      locations: [
                        {
                          physicalLocation: {
                            artifactLocation: { uri: finding.file },
                            region: {
                              startLine: finding.line,
                              startColumn: finding.column,
                            },
                          },
                        },
                      ],
                    })),
                  },
                ],
              };
              // Write SARIF file to filesystem
              const fs = require("fs");
              const path = require("path");
              const sarifFileName = "code-scanning-alert.sarif";
              const sarifFilePath = path.join(process.cwd(), sarifFileName);
              try {
                fs.writeFileSync(sarifFilePath, JSON.stringify(sarifContent, null, 2));
                core.info(`✓ Created SARIF file: ${sarifFilePath}`);
                core.info(`SARIF file size: ${fs.statSync(sarifFilePath).size} bytes`);
                // Set outputs for the GitHub Action
                core.setOutput("sarif_file", sarifFilePath);
                core.setOutput("findings_count", validFindings.length);
                core.setOutput("artifact_uploaded", "pending");
                core.setOutput("codeql_uploaded", "pending");
                // Write summary with findings
                let summaryContent = "\n\n## Code Scanning Alert\n";
                summaryContent += `Found **${validFindings.length}** security finding(s):\n\n`;
                for (const finding of validFindings) {
                  const emoji =
                    finding.severity === "error"
                      ? "🔴"
                      : finding.severity === "warning"
                        ? "🟡"
                        : "🔵";
                  summaryContent += `${emoji} **${finding.severity.toUpperCase()}** in \`${finding.file}:${finding.line}\`: ${finding.message}\n`;
                }
                summaryContent += `\n📄 SARIF file created: \`${sarifFileName}\`\n`;
                summaryContent += `🔍 Findings will be uploaded to GitHub Code Scanning\n`;
                await core.summary.addRaw(summaryContent).write();
              } catch (error) {
                core.error(
                  `✗ Failed to create SARIF file: ${error instanceof Error ? error.message : String(error)}`
                );
                throw error;
              }
              core.info(
                `Successfully created code scanning alert with ${validFindings.length} finding(s)`
              );
              return {
                sarifFile: sarifFilePath,
                findingsCount: validFindings.length,
                findings: validFindings,
              };
            }
            await main();
      - name: Upload SARIF artifact
        if: steps.create_code_scanning_alert.outputs.sarif_file
        uses: actions/upload-artifact@v4
        with:
          name: code-scanning-alert.sarif
          path: ${{ steps.create_code_scanning_alert.outputs.sarif_file }}
      - name: Upload SARIF to GitHub Security
        if: steps.create_code_scanning_alert.outputs.sarif_file
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: ${{ steps.create_code_scanning_alert.outputs.sarif_file }}

  create_pull_request:
    needs: test-safe-outputs-custom-engine
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    timeout-minutes: 10
    outputs:
      branch_name: ${{ steps.create_pull_request.outputs.branch_name }}
      pull_request_number: ${{ steps.create_pull_request.outputs.pull_request_number }}
      pull_request_url: ${{ steps.create_pull_request.outputs.pull_request_url }}
    steps:
      - name: Download patch artifact
        continue-on-error: true
        uses: actions/download-artifact@v5
        with:
          name: aw.patch
          path: /tmp/
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Configure Git credentials
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "${{ github.workflow }}"
          echo "Git configured with standard GitHub Actions identity"
      - name: Create Pull Request
        id: create_pull_request
        uses: actions/github-script@v7
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.test-safe-outputs-custom-engine.outputs.output }}
          GITHUB_AW_WORKFLOW_ID: "test-safe-outputs-custom-engine"
          GITHUB_AW_BASE_BRANCH: ${{ github.ref_name }}
          GITHUB_AW_PR_TITLE_PREFIX: "[Custom Engine Test] "
          GITHUB_AW_PR_LABELS: "test-safe-outputs,automation,custom-engine"
          GITHUB_AW_PR_DRAFT: "true"
          GITHUB_AW_PR_IF_NO_CHANGES: "warn"
        with:
          script: |
            /** @type {typeof import("fs")} */
            const fs = require("fs");
            /** @type {typeof import("crypto")} */
            const crypto = require("crypto");
            const { execSync } = require("child_process");
            async function main() {
              // Check if we're in staged mode
              const isStaged = process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true";
              // Environment validation - fail early if required variables are missing
              const workflowId = process.env.GITHUB_AW_WORKFLOW_ID;
              if (!workflowId) {
                throw new Error("GITHUB_AW_WORKFLOW_ID environment variable is required");
              }
              const baseBranch = process.env.GITHUB_AW_BASE_BRANCH;
              if (!baseBranch) {
                throw new Error("GITHUB_AW_BASE_BRANCH environment variable is required");
              }
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT || "";
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
              }
              const ifNoChanges = process.env.GITHUB_AW_PR_IF_NO_CHANGES || "warn";
              // Check if patch file exists and has valid content
              if (!fs.existsSync("/tmp/aw.patch")) {
                const message =
                  "No patch file found - cannot create pull request without changes";
                // If in staged mode, still show preview
                if (isStaged) {
                  let summaryContent = "## 🎭 Staged Mode: Create Pull Request Preview\n\n";
                  summaryContent +=
                    "The following pull request would be created if staged mode was disabled:\n\n";
                  summaryContent += `**Status:** ⚠️ No patch file found\n\n`;
                  summaryContent += `**Message:** ${message}\n\n`;
                  // Write to step summary
                  await core.summary.addRaw(summaryContent).write();
                  core.info(
                    "📝 Pull request creation preview written to step summary (no patch file)"
                  );
                  return;
                }
                switch (ifNoChanges) {
                  case "error":
                    throw new Error(message);
                  case "ignore":
                    // Silent success - no console output
                    return;
                  case "warn":
                  default:
                    core.warning(message);
                    return;
                }
              }
              const patchContent = fs.readFileSync("/tmp/aw.patch", "utf8");
              // Check for actual error conditions (but allow empty patches as valid noop)
              if (patchContent.includes("Failed to generate patch")) {
                const message =
                  "Patch file contains error message - cannot create pull request without changes";
                // If in staged mode, still show preview
                if (isStaged) {
                  let summaryContent = "## 🎭 Staged Mode: Create Pull Request Preview\n\n";
                  summaryContent +=
                    "The following pull request would be created if staged mode was disabled:\n\n";
                  summaryContent += `**Status:** ⚠️ Patch file contains error\n\n`;
                  summaryContent += `**Message:** ${message}\n\n`;
                  // Write to step summary
                  await core.summary.addRaw(summaryContent).write();
                  core.info(
                    "📝 Pull request creation preview written to step summary (patch error)"
                  );
                  return;
                }
                switch (ifNoChanges) {
                  case "error":
                    throw new Error(message);
                  case "ignore":
                    // Silent success - no console output
                    return;
                  case "warn":
                  default:
                    core.warning(message);
                    return;
                }
              }
              // Empty patch is valid - behavior depends on if-no-changes configuration
              const isEmpty = !patchContent || !patchContent.trim();
              if (isEmpty && !isStaged) {
                const message =
                  "Patch file is empty - no changes to apply (noop operation)";
                switch (ifNoChanges) {
                  case "error":
                    throw new Error(
                      "No changes to push - failing as configured by if-no-changes: error"
                    );
                  case "ignore":
                    // Silent success - no console output
                    return;
                  case "warn":
                  default:
                    core.warning(message);
                    return;
                }
              }
              core.debug(`Agent output content length: ${outputContent.length}`);
              if (!isEmpty) {
                core.info("Patch content validation passed");
              } else {
                core.info("Patch file is empty - processing noop operation");
              }
              // Parse the validated output JSON
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(
                  `Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`
                );
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.warning("No valid items found in agent output");
                return;
              }
              // Find the create-pull-request item
              const pullRequestItem = validatedOutput.items.find(
                /** @param {any} item */ item => item.type === "create-pull-request"
              );
              if (!pullRequestItem) {
                core.warning("No create-pull-request item found in agent output");
                return;
              }
              core.debug(
                `Found create-pull-request item: title="${pullRequestItem.title}", bodyLength=${pullRequestItem.body.length}`
              );
              // If in staged mode, emit step summary instead of creating PR
              if (isStaged) {
                let summaryContent = "## 🎭 Staged Mode: Create Pull Request Preview\n\n";
                summaryContent +=
                  "The following pull request would be created if staged mode was disabled:\n\n";
                summaryContent += `**Title:** ${pullRequestItem.title || "No title provided"}\n\n`;
                summaryContent += `**Branch:** ${pullRequestItem.branch || "auto-generated"}\n\n`;
                summaryContent += `**Base:** ${baseBranch}\n\n`;
                if (pullRequestItem.body) {
                  summaryContent += `**Body:**\n${pullRequestItem.body}\n\n`;
                }
                if (fs.existsSync("/tmp/aw.patch")) {
                  const patchStats = fs.readFileSync("/tmp/aw.patch", "utf8");
                  if (patchStats.trim()) {
                    summaryContent += `**Changes:** Patch file exists with ${patchStats.split("\n").length} lines\n\n`;
                    summaryContent += `<details><summary>Show patch preview</summary>\n\n\`\`\`diff\n${patchStats.slice(0, 2000)}${patchStats.length > 2000 ? "\n... (truncated)" : ""}\n\`\`\`\n\n</details>\n\n`;
                  } else {
                    summaryContent += `**Changes:** No changes (empty patch)\n\n`;
                  }
                }
                // Write to step summary
                await core.summary.addRaw(summaryContent).write();
                core.info("📝 Pull request creation preview written to step summary");
                return;
              }
              // Extract title, body, and branch from the JSON item
              let title = pullRequestItem.title.trim();
              let bodyLines = pullRequestItem.body.split("\n");
              let branchName = pullRequestItem.branch
                ? pullRequestItem.branch.trim()
                : null;
              // If no title was found, use a default
              if (!title) {
                title = "Agent Output";
              }
              // Apply title prefix if provided via environment variable
              const titlePrefix = process.env.GITHUB_AW_PR_TITLE_PREFIX;
              if (titlePrefix && !title.startsWith(titlePrefix)) {
                title = titlePrefix + title;
              }
              // Add AI disclaimer with run id, run htmlurl
              const runId = context.runId;
              const runUrl = context.payload.repository
                ? `${context.payload.repository.html_url}/actions/runs/${runId}`
                : `https://github.com/actions/runs/${runId}`;
              bodyLines.push(
                ``,
                ``,
                `> Generated by Agentic Workflow [Run](${runUrl})`,
                ""
              );
              // Prepare the body content
              const body = bodyLines.join("\n").trim();
              // Parse labels from environment variable (comma-separated string)
              const labelsEnv = process.env.GITHUB_AW_PR_LABELS;
              const labels = labelsEnv
                ? labelsEnv
                    .split(",")
                    .map(/** @param {string} label */ label => label.trim())
                    .filter(/** @param {string} label */ label => label)
                : [];
              // Parse draft setting from environment variable (defaults to true)
              const draftEnv = process.env.GITHUB_AW_PR_DRAFT;
              const draft = draftEnv ? draftEnv.toLowerCase() === "true" : true;
              core.info(`Creating pull request with title: ${title}`);
              core.debug(`Labels: ${JSON.stringify(labels)}`);
              core.debug(`Draft: ${draft}`);
              core.debug(`Body length: ${body.length}`);
              const randomHex = crypto.randomBytes(8).toString("hex");
              // Use branch name from JSONL if provided, otherwise generate unique branch name
              if (!branchName) {
                core.debug(
                  "No branch name provided in JSONL, generating unique branch name"
                );
                // Generate unique branch name using cryptographic random hex
                branchName = `${workflowId}-${randomHex}`;
              } else {
                branchName = `${branchName}-${randomHex}`;
                core.debug(`Using branch name from JSONL with added salt: ${branchName}`);
              }
              core.info(`Generated branch name: ${branchName}`);
              core.debug(`Base branch: ${baseBranch}`);
              // Create a new branch using git CLI, ensuring it's based on the correct base branch
              // First, fetch latest changes and checkout the base branch
              core.debug(
                `Fetching latest changes and checking out base branch: ${baseBranch}`
              );
              execSync("git fetch origin", { stdio: "inherit" });
              execSync(`git checkout ${baseBranch}`, { stdio: "inherit" });
              // Handle branch creation/checkout
              core.debug(
                `Branch should not exist locally, creating new branch from base: ${branchName}`
              );
              execSync(`git checkout -b ${branchName}`, { stdio: "inherit" });
              core.info(`Created new branch from base: ${branchName}`);
              // Apply the patch using git CLI (skip if empty)
              if (!isEmpty) {
                core.info("Applying patch...");
                // Patches are created with git format-patch, so use git am to apply them
                execSync("git am /tmp/aw.patch", { stdio: "inherit" });
                core.info("Patch applied successfully");
                // Push the applied commits to the branch
                execSync(`git push origin ${branchName}`, { stdio: "inherit" });
                core.info("Changes pushed to branch");
              } else {
                core.info("Skipping patch application (empty patch)");
                // For empty patches, handle if-no-changes configuration
                const message =
                  "No changes to apply - noop operation completed successfully";
                switch (ifNoChanges) {
                  case "error":
                    throw new Error(
                      "No changes to apply - failing as configured by if-no-changes: error"
                    );
                  case "ignore":
                    // Silent success - no console output
                    return;
                  case "warn":
                  default:
                    core.warning(message);
                    return;
                }
              }
              // Create the pull request
              const { data: pullRequest } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                head: branchName,
                base: baseBranch,
                draft: draft,
              });
              core.info(
                `Created pull request #${pullRequest.number}: ${pullRequest.html_url}`
              );
              // Add labels if specified
              if (labels.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pullRequest.number,
                  labels: labels,
                });
                core.info(`Added labels to pull request: ${JSON.stringify(labels)}`);
              }
              // Set output for other jobs to use
              core.setOutput("pull_request_number", pullRequest.number);
              core.setOutput("pull_request_url", pullRequest.html_url);
              core.setOutput("branch_name", branchName);
              // Write summary to GitHub Actions summary
              await core.summary
                .addRaw(
                  `
            ## Pull Request
            - **Pull Request**: [#${pullRequest.number}](${pullRequest.html_url})
            - **Branch**: \`${branchName}\`
            - **Base Branch**: \`${baseBranch}\`
            `
                )
                .write();
            }
            await main();

  add_labels:
    needs: test-safe-outputs-custom-engine
    if: github.event.issue.number || github.event.pull_request.number
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
    timeout-minutes: 10
    outputs:
      labels_added: ${{ steps.add_labels.outputs.labels_added }}
    steps:
      - name: Add Labels
        id: add_labels
        uses: actions/github-script@v7
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.test-safe-outputs-custom-engine.outputs.output }}
          GITHUB_AW_LABELS_ALLOWED: "test-safe-outputs,automation,custom-engine,bug,enhancement,documentation"
          GITHUB_AW_LABELS_MAX_COUNT: 3
        with:
          script: |
            async function main() {
              // Read the validated output content from environment variable
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT;
              if (!outputContent) {
                core.info("No GITHUB_AW_AGENT_OUTPUT environment variable found");
                return;
              }
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
                return;
              }
              core.debug(`Agent output content length: ${outputContent.length}`);
              // Parse the validated output JSON
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(
                  `Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`
                );
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.warning("No valid items found in agent output");
                return;
              }
              // Find the add-issue-label item
              const labelsItem = validatedOutput.items.find(
                /** @param {any} item */ item => item.type === "add-issue-label"
              );
              if (!labelsItem) {
                core.warning("No add-issue-label item found in agent output");
                return;
              }
              core.debug(
                `Found add-issue-label item with ${labelsItem.labels.length} labels`
              );
              // If in staged mode, emit step summary instead of adding labels
              if (process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true") {
                let summaryContent = "## 🎭 Staged Mode: Add Labels Preview\n\n";
                summaryContent +=
                  "The following labels would be added if staged mode was disabled:\n\n";
                if (labelsItem.issue_number) {
                  summaryContent += `**Target Issue:** #${labelsItem.issue_number}\n\n`;
                } else {
                  summaryContent += `**Target:** Current issue/PR\n\n`;
                }
                if (labelsItem.labels && labelsItem.labels.length > 0) {
                  summaryContent += `**Labels to add:** ${labelsItem.labels.join(", ")}\n\n`;
                }
                // Write to step summary
                await core.summary.addRaw(summaryContent).write();
                core.info("📝 Label addition preview written to step summary");
                return;
              }
              // Read the allowed labels from environment variable (optional)
              const allowedLabelsEnv = process.env.GITHUB_AW_LABELS_ALLOWED;
              let allowedLabels = null;
              if (allowedLabelsEnv && allowedLabelsEnv.trim() !== "") {
                allowedLabels = allowedLabelsEnv
                  .split(",")
                  .map(label => label.trim())
                  .filter(label => label);
                if (allowedLabels.length === 0) {
                  allowedLabels = null; // Treat empty list as no restrictions
                }
              }
              if (allowedLabels) {
                core.debug(`Allowed labels: ${JSON.stringify(allowedLabels)}`);
              } else {
                core.debug("No label restrictions - any labels are allowed");
              }
              // Read the max limit from environment variable (default: 3)
              const maxCountEnv = process.env.GITHUB_AW_LABELS_MAX_COUNT;
              const maxCount = maxCountEnv ? parseInt(maxCountEnv, 10) : 3;
              if (isNaN(maxCount) || maxCount < 1) {
                core.setFailed(
                  `Invalid max value: ${maxCountEnv}. Must be a positive integer`
                );
                return;
              }
              core.debug(`Max count: ${maxCount}`);
              // Check if we're in an issue or pull request context
              const isIssueContext =
                context.eventName === "issues" || context.eventName === "issue_comment";
              const isPRContext =
                context.eventName === "pull_request" ||
                context.eventName === "pull_request_review" ||
                context.eventName === "pull_request_review_comment";
              if (!isIssueContext && !isPRContext) {
                core.setFailed(
                  "Not running in issue or pull request context, skipping label addition"
                );
                return;
              }
              // Determine the issue/PR number
              let issueNumber;
              let contextType;
              if (isIssueContext) {
                if (context.payload.issue) {
                  issueNumber = context.payload.issue.number;
                  contextType = "issue";
                } else {
                  core.setFailed("Issue context detected but no issue found in payload");
                  return;
                }
              } else if (isPRContext) {
                if (context.payload.pull_request) {
                  issueNumber = context.payload.pull_request.number;
                  contextType = "pull request";
                } else {
                  core.setFailed(
                    "Pull request context detected but no pull request found in payload"
                  );
                  return;
                }
              }
              if (!issueNumber) {
                core.setFailed("Could not determine issue or pull request number");
                return;
              }
              // Extract labels from the JSON item
              const requestedLabels = labelsItem.labels || [];
              core.debug(`Requested labels: ${JSON.stringify(requestedLabels)}`);
              // Check for label removal attempts (labels starting with '-')
              for (const label of requestedLabels) {
                if (label.startsWith("-")) {
                  core.setFailed(
                    `Label removal is not permitted. Found line starting with '-': ${label}`
                  );
                  return;
                }
              }
              // Validate that all requested labels are in the allowed list (if restrictions are set)
              let validLabels;
              if (allowedLabels) {
                validLabels = requestedLabels.filter(
                  /** @param {string} label */ label => allowedLabels.includes(label)
                );
              } else {
                // No restrictions, all requested labels are valid
                validLabels = requestedLabels;
              }
              // Remove duplicates from requested labels
              let uniqueLabels = [...new Set(validLabels)];
              // Enforce max limit
              if (uniqueLabels.length > maxCount) {
                core.debug(`too many labels, keep ${maxCount}`);
                uniqueLabels = uniqueLabels.slice(0, maxCount);
              }
              if (uniqueLabels.length === 0) {
                core.info("No labels to add");
                core.setOutput("labels_added", "");
                await core.summary
                  .addRaw(
                    `
            ## Label Addition
            No labels were added (no valid labels found in agent output).
            `
                  )
                  .write();
                return;
              }
              core.info(
                `Adding ${uniqueLabels.length} labels to ${contextType} #${issueNumber}: ${JSON.stringify(uniqueLabels)}`
              );
              try {
                // Add labels using GitHub API
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: uniqueLabels,
                });
                core.info(
                  `Successfully added ${uniqueLabels.length} labels to ${contextType} #${issueNumber}`
                );
                // Set output for other jobs to use
                core.setOutput("labels_added", uniqueLabels.join("\n"));
                // Write summary
                const labelsListMarkdown = uniqueLabels
                  .map(label => `- \`${label}\``)
                  .join("\n");
                await core.summary
                  .addRaw(
                    `
            ## Label Addition
            Successfully added ${uniqueLabels.length} label(s) to ${contextType} #${issueNumber}:
            ${labelsListMarkdown}
            `
                  )
                  .write();
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                core.error(`Failed to add labels: ${errorMessage}`);
                core.setFailed(`Failed to add labels: ${errorMessage}`);
              }
            }
            await main();

  update_issue:
    needs: test-safe-outputs-custom-engine
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    timeout-minutes: 10
    outputs:
      issue_number: ${{ steps.update_issue.outputs.issue_number }}
      issue_url: ${{ steps.update_issue.outputs.issue_url }}
    steps:
      - name: Update Issue
        id: update_issue
        uses: actions/github-script@v7
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.test-safe-outputs-custom-engine.outputs.output }}
          GITHUB_AW_UPDATE_STATUS: true
          GITHUB_AW_UPDATE_TITLE: true
          GITHUB_AW_UPDATE_BODY: true
          GITHUB_AW_UPDATE_TARGET: "*"
        with:
          script: |
            async function main() {
              // Check if we're in staged mode
              const isStaged = process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true";
              // Read the validated output content from environment variable
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT;
              if (!outputContent) {
                core.info("No GITHUB_AW_AGENT_OUTPUT environment variable found");
                return;
              }
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
                return;
              }
              core.info(`Agent output content length: ${outputContent.length}`);
              // Parse the validated output JSON
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(
                  `Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`
                );
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.info("No valid items found in agent output");
                return;
              }
              // Find all update-issue items
              const updateItems = validatedOutput.items.filter(
                /** @param {any} item */ item => item.type === "update-issue"
              );
              if (updateItems.length === 0) {
                core.info("No update-issue items found in agent output");
                return;
              }
              core.info(`Found ${updateItems.length} update-issue item(s)`);
              // If in staged mode, emit step summary instead of updating issues
              if (isStaged) {
                let summaryContent = "## 🎭 Staged Mode: Update Issues Preview\n\n";
                summaryContent +=
                  "The following issue updates would be applied if staged mode was disabled:\n\n";
                for (let i = 0; i < updateItems.length; i++) {
                  const item = updateItems[i];
                  summaryContent += `### Issue Update ${i + 1}\n`;
                  if (item.issue_number) {
                    summaryContent += `**Target Issue:** #${item.issue_number}\n\n`;
                  } else {
                    summaryContent += `**Target:** Current issue\n\n`;
                  }
                  if (item.title !== undefined) {
                    summaryContent += `**New Title:** ${item.title}\n\n`;
                  }
                  if (item.body !== undefined) {
                    summaryContent += `**New Body:**\n${item.body}\n\n`;
                  }
                  if (item.status !== undefined) {
                    summaryContent += `**New Status:** ${item.status}\n\n`;
                  }
                  summaryContent += "---\n\n";
                }
                // Write to step summary
                await core.summary.addRaw(summaryContent).write();
                core.info("📝 Issue update preview written to step summary");
                return;
              }
              // Get the configuration from environment variables
              const updateTarget = process.env.GITHUB_AW_UPDATE_TARGET || "triggering";
              const canUpdateStatus = process.env.GITHUB_AW_UPDATE_STATUS === "true";
              const canUpdateTitle = process.env.GITHUB_AW_UPDATE_TITLE === "true";
              const canUpdateBody = process.env.GITHUB_AW_UPDATE_BODY === "true";
              core.info(`Update target configuration: ${updateTarget}`);
              core.info(
                `Can update status: ${canUpdateStatus}, title: ${canUpdateTitle}, body: ${canUpdateBody}`
              );
              // Check if we're in an issue context
              const isIssueContext =
                context.eventName === "issues" || context.eventName === "issue_comment";
              // Validate context based on target configuration
              if (updateTarget === "triggering" && !isIssueContext) {
                core.info(
                  'Target is "triggering" but not running in issue context, skipping issue update'
                );
                return;
              }
              const updatedIssues = [];
              // Process each update item
              for (let i = 0; i < updateItems.length; i++) {
                const updateItem = updateItems[i];
                core.info(`Processing update-issue item ${i + 1}/${updateItems.length}`);
                // Determine the issue number for this update
                let issueNumber;
                if (updateTarget === "*") {
                  // For target "*", we need an explicit issue number from the update item
                  if (updateItem.issue_number) {
                    issueNumber = parseInt(updateItem.issue_number, 10);
                    if (isNaN(issueNumber) || issueNumber <= 0) {
                      core.info(
                        `Invalid issue number specified: ${updateItem.issue_number}`
                      );
                      continue;
                    }
                  } else {
                    core.info('Target is "*" but no issue_number specified in update item');
                    continue;
                  }
                } else if (updateTarget && updateTarget !== "triggering") {
                  // Explicit issue number specified in target
                  issueNumber = parseInt(updateTarget, 10);
                  if (isNaN(issueNumber) || issueNumber <= 0) {
                    core.info(
                      `Invalid issue number in target configuration: ${updateTarget}`
                    );
                    continue;
                  }
                } else {
                  // Default behavior: use triggering issue
                  if (isIssueContext) {
                    if (context.payload.issue) {
                      issueNumber = context.payload.issue.number;
                    } else {
                      core.info("Issue context detected but no issue found in payload");
                      continue;
                    }
                  } else {
                    core.info("Could not determine issue number");
                    continue;
                  }
                }
                if (!issueNumber) {
                  core.info("Could not determine issue number");
                  continue;
                }
                core.info(`Updating issue #${issueNumber}`);
                // Build the update object based on allowed fields and provided values
                /** @type {any} */
                const updateData = {};
                let hasUpdates = false;
                if (canUpdateStatus && updateItem.status !== undefined) {
                  // Validate status value
                  if (updateItem.status === "open" || updateItem.status === "closed") {
                    updateData.state = updateItem.status;
                    hasUpdates = true;
                    core.info(`Will update status to: ${updateItem.status}`);
                  } else {
                    core.info(
                      `Invalid status value: ${updateItem.status}. Must be 'open' or 'closed'`
                    );
                  }
                }
                if (canUpdateTitle && updateItem.title !== undefined) {
                  if (
                    typeof updateItem.title === "string" &&
                    updateItem.title.trim().length > 0
                  ) {
                    updateData.title = updateItem.title.trim();
                    hasUpdates = true;
                    core.info(`Will update title to: ${updateItem.title.trim()}`);
                  } else {
                    core.info("Invalid title value: must be a non-empty string");
                  }
                }
                if (canUpdateBody && updateItem.body !== undefined) {
                  if (typeof updateItem.body === "string") {
                    updateData.body = updateItem.body;
                    hasUpdates = true;
                    core.info(`Will update body (length: ${updateItem.body.length})`);
                  } else {
                    core.info("Invalid body value: must be a string");
                  }
                }
                if (!hasUpdates) {
                  core.info("No valid updates to apply for this item");
                  continue;
                }
                try {
                  // Update the issue using GitHub API
                  const { data: issue } = await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    ...updateData,
                  });
                  core.info("Updated issue #" + issue.number + ": " + issue.html_url);
                  updatedIssues.push(issue);
                  // Set output for the last updated issue (for backward compatibility)
                  if (i === updateItems.length - 1) {
                    core.setOutput("issue_number", issue.number);
                    core.setOutput("issue_url", issue.html_url);
                  }
                } catch (error) {
                  core.error(
                    `✗ Failed to update issue #${issueNumber}: ${error instanceof Error ? error.message : String(error)}`
                  );
                  throw error;
                }
              }
              // Write summary for all updated issues
              if (updatedIssues.length > 0) {
                let summaryContent = "\n\n## Updated Issues\n";
                for (const issue of updatedIssues) {
                  summaryContent += `- Issue #${issue.number}: [${issue.title}](${issue.html_url})\n`;
                }
                await core.summary.addRaw(summaryContent).write();
              }
              core.info(`Successfully updated ${updatedIssues.length} issue(s)`);
              return updatedIssues;
            }
            await main();

  push_to_pr_branch:
    needs: test-safe-outputs-custom-engine
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
      issues: read
    timeout-minutes: 10
    outputs:
      branch_name: ${{ steps.push_to_pr_branch.outputs.branch_name }}
      commit_sha: ${{ steps.push_to_pr_branch.outputs.commit_sha }}
      push_url: ${{ steps.push_to_pr_branch.outputs.push_url }}
    steps:
      - name: Download patch artifact
        continue-on-error: true
        uses: actions/download-artifact@v5
        with:
          name: aw.patch
          path: /tmp/
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Configure Git credentials
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "${{ github.workflow }}"
          echo "Git configured with standard GitHub Actions identity"
      - name: Push to Branch
        id: push_to_pr_branch
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ github.token }}
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.test-safe-outputs-custom-engine.outputs.output }}
          GITHUB_AW_PUSH_TARGET: "*"
          GITHUB_AW_PUSH_IF_NO_CHANGES: "warn"
        with:
          script: |
            async function main() {
              /** @type {typeof import("fs")} */
              const fs = require("fs");
              const { execSync } = require("child_process");
              // Environment validation - fail early if required variables are missing
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT || "";
              if (outputContent.trim() === "") {
                core.info("Agent output content is empty");
                return;
              }
              const target = process.env.GITHUB_AW_PUSH_TARGET || "triggering";
              const ifNoChanges = process.env.GITHUB_AW_PUSH_IF_NO_CHANGES || "warn";
              // Check if patch file exists and has valid content
              if (!fs.existsSync("/tmp/aw.patch")) {
                const message = "No patch file found - cannot push without changes";
                switch (ifNoChanges) {
                  case "error":
                    core.setFailed(message);
                    return;
                  case "ignore":
                    // Silent success - no console output
                    return;
                  case "warn":
                  default:
                    core.info(message);
                    return;
                }
              }
              const patchContent = fs.readFileSync("/tmp/aw.patch", "utf8");
              // Check for actual error conditions (but allow empty patches as valid noop)
              if (patchContent.includes("Failed to generate patch")) {
                const message =
                  "Patch file contains error message - cannot push without changes";
                switch (ifNoChanges) {
                  case "error":
                    core.setFailed(message);
                    return;
                  case "ignore":
                    // Silent success - no console output
                    return;
                  case "warn":
                  default:
                    core.info(message);
                    return;
                }
              }
              // Empty patch is valid - behavior depends on if-no-changes configuration
              const isEmpty = !patchContent || !patchContent.trim();
              if (isEmpty) {
                const message =
                  "Patch file is empty - no changes to apply (noop operation)";
                switch (ifNoChanges) {
                  case "error":
                    core.setFailed(
                      "No changes to push - failing as configured by if-no-changes: error"
                    );
                    return;
                  case "ignore":
                    // Silent success - no console output
                    break;
                  case "warn":
                  default:
                    core.info(message);
                    break;
                }
              }
              core.info(`Agent output content length: ${outputContent.length}`);
              if (!isEmpty) {
                core.info("Patch content validation passed");
              }
              core.info(`Target configuration: ${target}`);
              // Parse the validated output JSON
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(outputContent);
              } catch (error) {
                core.setFailed(
                  `Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`
                );
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.info("No valid items found in agent output");
                return;
              }
              // Find the push-to-pr-branch item
              const pushItem = validatedOutput.items.find(
                /** @param {any} item */ item => item.type === "push-to-pr-branch"
              );
              if (!pushItem) {
                core.info("No push-to-pr-branch item found in agent output");
                return;
              }
              core.info("Found push-to-pr-branch item");
              // If in staged mode, emit step summary instead of pushing changes
              if (process.env.GITHUB_AW_SAFE_OUTPUTS_STAGED === "true") {
                let summaryContent = "## 🎭 Staged Mode: Push to PR Branch Preview\n\n";
                summaryContent +=
                  "The following changes would be pushed if staged mode was disabled:\n\n";
                summaryContent += `**Target:** ${target}\n\n`;
                if (pushItem.commit_message) {
                  summaryContent += `**Commit Message:** ${pushItem.commit_message}\n\n`;
                }
                if (fs.existsSync("/tmp/aw.patch")) {
                  const patchStats = fs.readFileSync("/tmp/aw.patch", "utf8");
                  if (patchStats.trim()) {
                    summaryContent += `**Changes:** Patch file exists with ${patchStats.split("\n").length} lines\n\n`;
                    summaryContent += `<details><summary>Show patch preview</summary>\n\n\`\`\`diff\n${patchStats.slice(0, 2000)}${patchStats.length > 2000 ? "\n... (truncated)" : ""}\n\`\`\`\n\n</details>\n\n`;
                  } else {
                    summaryContent += `**Changes:** No changes (empty patch)\n\n`;
                  }
                }
                // Write to step summary
                await core.summary.addRaw(summaryContent).write();
                core.info("📝 Push to PR branch preview written to step summary");
                return;
              }
              // Validate target configuration for pull request context
              if (target !== "*" && target !== "triggering") {
                // If target is a specific number, validate it's a valid pull request number
                const pullNumber = parseInt(target, 10);
                if (isNaN(pullNumber)) {
                  core.setFailed(
                    'Invalid target configuration: must be "triggering", "*", or a valid pull request number'
                  );
                  return;
                }
              }
              // Compute the target branch name based on target configuration
              let pullNumber;
              if (target === "triggering") {
                // Use the number of the triggering pull request
                pullNumber =
                  context.payload?.pull_request?.number || context.payload?.issue?.number;
                // Check if we're in a pull request context when required
                if (!pullNumber) {
                  core.setFailed(
                    'push-to-pr-branch with target "triggering" requires pull request context'
                  );
                  return;
                }
              } else if (target === "*") {
                if (pushItem.pull_number) {
                  pullNumber = parseInt(pushItem.pull_number, 10);
                }
              } else {
                // Target is a specific pull request number
                pullNumber = parseInt(target, 10);
              }
              let branchName;
              // Fetch the specific PR to get its head branch
              try {
                const prInfo = execSync(
                  `gh pr view ${pullNumber} --json headRefName --jq '.headRefName'`,
                  { encoding: "utf8" }
                ).trim();
                if (prInfo) {
                  branchName = prInfo;
                } else {
                  throw new Error("No head branch found for PR");
                }
              } catch (error) {
                core.info(
                  `Warning: Could not fetch PR ${pullNumber} details: ${error instanceof Error ? error.message : String(error)}`
                );
                // Exit with failure if we cannot determine the branch name
                core.setFailed(`Failed to determine branch name for PR ${pullNumber}`);
                return;
              }
              core.info(`Target branch: ${branchName}`);
              // Check if patch has actual changes (not just empty)
              const hasChanges = !isEmpty;
              // Switch to or create the target branch
              core.info(`Switching to branch: ${branchName}`);
              try {
                // Try to checkout existing branch first
                execSync("git fetch origin", { stdio: "inherit" });
                // Check if branch exists on origin
                try {
                  execSync(`git rev-parse --verify origin/${branchName}`, {
                    stdio: "pipe",
                  });
                  // Branch exists on origin, check it out
                  execSync(`git checkout -B ${branchName} origin/${branchName}`, {
                    stdio: "inherit",
                  });
                  core.info(`Checked out existing branch from origin: ${branchName}`);
                } catch (originError) {
                  // Branch doesn't exist on origin, check if it exists locally
                  try {
                    execSync(`git rev-parse --verify ${branchName}`, { stdio: "pipe" });
                    // Branch exists locally, check it out
                    execSync(`git checkout ${branchName}`, { stdio: "inherit" });
                    core.info(`Checked out existing local branch: ${branchName}`);
                  } catch (localError) {
                    // Branch doesn't exist locally or on origin, create it from default branch
                    core.info(
                      `Branch does not exist, creating new branch from default branch: ${branchName}`
                    );
                    // Get the default branch name
                    const defaultBranch = execSync(
                      "git remote show origin | grep 'HEAD branch' | cut -d' ' -f5",
                      { encoding: "utf8" }
                    ).trim();
                    core.info(`Default branch: ${defaultBranch}`);
                    // Ensure we have the latest default branch
                    execSync(`git checkout ${defaultBranch}`, { stdio: "inherit" });
                    execSync(`git pull origin ${defaultBranch}`, { stdio: "inherit" });
                    // Create new branch from default branch
                    execSync(`git checkout -b ${branchName}`, { stdio: "inherit" });
                    core.info(`Created new branch from default branch: ${branchName}`);
                  }
                }
              } catch (error) {
                core.setFailed(
                  `Failed to switch to branch ${branchName}: ${error instanceof Error ? error.message : String(error)}`
                );
                return;
              }
              // Apply the patch using git CLI (skip if empty)
              if (!isEmpty) {
                core.info("Applying patch...");
                try {
                  // Patches are created with git format-patch, so use git am to apply them
                  execSync("git am /tmp/aw.patch", { stdio: "inherit" });
                  core.info("Patch applied successfully");
                  // Push the applied commits to the branch
                  execSync(`git push origin ${branchName}`, { stdio: "inherit" });
                  core.info(`Changes committed and pushed to branch: ${branchName}`);
                } catch (error) {
                  core.error(
                    `Failed to apply patch: ${error instanceof Error ? error.message : String(error)}`
                  );
                  core.setFailed("Failed to apply patch");
                  return;
                }
              } else {
                core.info("Skipping patch application (empty patch)");
                // Handle if-no-changes configuration for empty patches
                const message =
                  "No changes to apply - noop operation completed successfully";
                switch (ifNoChanges) {
                  case "error":
                    core.setFailed(
                      "No changes to apply - failing as configured by if-no-changes: error"
                    );
                    return;
                  case "ignore":
                    // Silent success - no console output
                    break;
                  case "warn":
                  default:
                    core.info(message);
                    break;
                }
              }
              // Get commit SHA and push URL
              const commitSha = execSync("git rev-parse HEAD", { encoding: "utf8" }).trim();
              // Get commit SHA and push URL
              const pushUrl = context.payload.repository
                ? `${context.payload.repository.html_url}/tree/${branchName}`
                : `https://github.com/${context.repo.owner}/${context.repo.repo}/tree/${branchName}`;
              // Set outputs
              core.setOutput("branch_name", branchName);
              core.setOutput("commit_sha", commitSha);
              core.setOutput("push_url", pushUrl);
              // Write summary to GitHub Actions summary
              const summaryTitle = hasChanges
                ? "Push to Branch"
                : "Push to Branch (No Changes)";
              const summaryContent = hasChanges
                ? `
            ## ${summaryTitle}
            - **Branch**: \`${branchName}\`
            - **Commit**: [${commitSha.substring(0, 7)}](${pushUrl})
            - **URL**: [${pushUrl}](${pushUrl})
            `
                : `
            ## ${summaryTitle}
            - **Branch**: \`${branchName}\`
            - **Status**: No changes to apply (noop operation)
            - **URL**: [${pushUrl}](${pushUrl})
            `;
              await core.summary.addRaw(summaryContent).write();
            }
            await main();

  missing_tool:
    needs: test-safe-outputs-custom-engine
    if: ${{ always() }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 5
    outputs:
      tools_reported: ${{ steps.missing_tool.outputs.tools_reported }}
      total_count: ${{ steps.missing_tool.outputs.total_count }}
    steps:
      - name: Record Missing Tool
        id: missing_tool
        uses: actions/github-script@v7
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.test-safe-outputs-custom-engine.outputs.output }}
          GITHUB_AW_MISSING_TOOL_MAX: 5
        with:
          script: |
            async function main() {
              const fs = require("fs");
              // Get environment variables
              const agentOutput = process.env.GITHUB_AW_AGENT_OUTPUT || "";
              const maxReports = process.env.GITHUB_AW_MISSING_TOOL_MAX
                ? parseInt(process.env.GITHUB_AW_MISSING_TOOL_MAX)
                : null;
              core.info("Processing missing-tool reports...");
              core.info(`Agent output length: ${agentOutput.length}`);
              if (maxReports) {
                core.info(`Maximum reports allowed: ${maxReports}`);
              }
              /** @type {any[]} */
              const missingTools = [];
              // Return early if no agent output
              if (!agentOutput.trim()) {
                core.info("No agent output to process");
                core.setOutput("tools_reported", JSON.stringify(missingTools));
                core.setOutput("total_count", missingTools.length.toString());
                return;
              }
              // Parse the validated output JSON
              let validatedOutput;
              try {
                validatedOutput = JSON.parse(agentOutput);
              } catch (error) {
                core.setFailed(
                  `Error parsing agent output JSON: ${error instanceof Error ? error.message : String(error)}`
                );
                return;
              }
              if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
                core.info("No valid items found in agent output");
                core.setOutput("tools_reported", JSON.stringify(missingTools));
                core.setOutput("total_count", missingTools.length.toString());
                return;
              }
              core.info(`Parsed agent output with ${validatedOutput.items.length} entries`);
              // Process all parsed entries
              for (const entry of validatedOutput.items) {
                if (entry.type === "missing-tool") {
                  // Validate required fields
                  if (!entry.tool) {
                    core.warning(
                      `missing-tool entry missing 'tool' field: ${JSON.stringify(entry)}`
                    );
                    continue;
                  }
                  if (!entry.reason) {
                    core.warning(
                      `missing-tool entry missing 'reason' field: ${JSON.stringify(entry)}`
                    );
                    continue;
                  }
                  const missingTool = {
                    tool: entry.tool,
                    reason: entry.reason,
                    alternatives: entry.alternatives || null,
                    timestamp: new Date().toISOString(),
                  };
                  missingTools.push(missingTool);
                  core.info(`Recorded missing tool: ${missingTool.tool}`);
                  // Check max limit
                  if (maxReports && missingTools.length >= maxReports) {
                    core.info(
                      `Reached maximum number of missing tool reports (${maxReports})`
                    );
                    break;
                  }
                }
              }
              core.info(`Total missing tools reported: ${missingTools.length}`);
              // Output results
              core.setOutput("tools_reported", JSON.stringify(missingTools));
              core.setOutput("total_count", missingTools.length.toString());
              // Log details for debugging
              if (missingTools.length > 0) {
                core.info("Missing tools summary:");
                missingTools.forEach((tool, index) => {
                  core.info(`${index + 1}. Tool: ${tool.tool}`);
                  core.info(`   Reason: ${tool.reason}`);
                  if (tool.alternatives) {
                    core.info(`   Alternatives: ${tool.alternatives}`);
                  }
                  core.info(`   Reported at: ${tool.timestamp}`);
                  core.info("");
                });
              } else {
                core.info("No missing tools reported in this workflow execution.");
              }
            }
            main().catch(error => {
              core.error(`Error processing missing-tool reports: ${error}`);
              core.setFailed(`Error processing missing-tool reports: ${error}`);
            });

